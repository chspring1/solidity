// SPDX-License-Identifier: MIT
// SPDX许可证标识符：MIT开源许可证
// 用途：明确代码的许可证类型，避免版权纠纷
// MIT许可证特点：允许自由使用、修改、分发，仅需保留版权声明
pragma solidity ^0.8.0;
// 编译器版本声明：指定Solidity编译器版本
// ^0.8.0：兼容0.8.0及以上版本，但不包括0.9.0（向上兼容但不跨主版本）
// 版本选择原因：0.8.0引入了重要的安全改进（如自动溢出检查）

/**
 * @title HelloSolidity - Solidity语言全特性演示合约
 * @dev 这是一个全面的Solidity教学合约，包含了所有主要语言特性
 * 
 * 合约功能概述：
 * - 数据类型：基本类型、复合类型、引用类型的完整演示
 * - 存储结构：状态变量、映射、数组的不同使用场景
 * - 控制流程：条件判断、循环、迭代的各种实现方式
 * - 函数特性：可见性、修饰符、参数传递、返回值处理
 * - 高级特性：事件记录、错误处理、安全实践
 * - 实用示例：实际开发中的常见模式和最佳实践
 * 
 * 学习目标：
 * 1. 掌握Solidity的核心语法和概念
 * 2. 理解智能合约的运行机制和gas消耗
 * 3. 学习安全的合约开发实践
 * 4. 熟悉常见的设计模式和优化技巧
 * 
 * @author Solidity学习教程
 * @notice 本合约仅用于教学目的，包含详细的代码注释和特性说明
 * @custom:educational 适合Solidity初学者到中级开发者的完整学习资源
 */
contract HelloSolidity {
    // ============ 状态变量 (State Variables) ============
    // 状态变量是合约的永久数据，存储在区块链的存储空间中
    // 
    // 重要特性：
    // 1. 持久化存储：数据永久保存在区块链上，除非合约被销毁
    // 2. 全局可访问：合约内的所有函数都可以读取和修改（根据可见性）
    // 3. Gas消耗：读取消耗少量gas，写入消耗较多gas
    // 4. 存储布局：按32字节槽进行存储，小类型可以打包在同一槽中
    // 5. 默认值：所有状态变量都有默认值（如uint默认为0，bool默认为false）
    // 
    // 存储成本：
    // - 首次写入：20,000 gas（SSTORE从0到非0）
    // - 修改现有值：5,000 gas（SSTORE从非0到非0）
    // - 删除值：退还15,000 gas（SSTORE从非0到0）
    // - 读取值：200 gas（SLOAD操作）
    
    // ========== 基本数据类型 (Primitive Data Types) ==========
    // Solidity提供了多种基本数据类型，每种都有其特定的用途和特性
    
    string public message;        
    // 字符串类型详解：
    // - 数据结构：动态长度的UTF-8编码字符串
    // - 存储方式：如果长度≤31字节，存储在单个槽中；否则使用多槽存储
    // - 内存布局：前32字节存储长度，后续字节存储实际数据
    // - Gas消耗：按字节数计算，约每字节3-8 gas
    // - 操作限制：不支持直接比较，需要通过keccak256哈希比较
    // - 使用场景：存储文本信息、描述、名称等
    // - public修饰符：自动生成getter函数message()，外部可调用
    
    address public owner;         
    // 地址类型详解：
    // - 数据长度：20字节（160位），以0x开头的十六进制表示
    // - 存储成本：一个完整的存储槽（32字节），但只使用前20字节
    // - 内置属性：balance（查询该地址的以太币余额）
    // - 内置方法：transfer(), send(), call(), delegatecall(), staticcall()
    // - 转账功能：可以直接发送以太币到该地址
    // - 类型转换：可以与uint160相互转换
    // - 地址校验：EIP-55引入校验和机制防止地址错误
    // - 零地址：0x0000000000000000000000000000000000000000表示无效地址
    // - 使用场景：标识账户、合约地址、权限控制等
    // - 特殊地址：msg.sender（调用者）、block.coinbase（矿工地址）等
    
    uint256 public count;         
    // 计数器变量详解：
    // - 基础类型：uint256（无符号256位整数）
    // - 数值范围：0 到 115792089237316195423570985008687907853269984665640564039457584007913129639935
    // - 存储优化：单独占用一个32字节存储槽
    // - 算术安全：自动检查溢出（Solidity 0.8+），操作失败会回滚交易
    // - 递增操作：支持 ++count 和 count++，前者稍微节省gas
    // - 初始值：默认为0，无需显式初始化
    // - Gas消耗：首次赋值20,000 gas，后续修改5,000 gas
    // - 常见用途：循环计数、事件计数、用户操作次数统计
    // - 安全考虑：在循环中使用时要注意gas限制
    
    bool public isActive;         
    // 布尔类型详解：
    // - 存储大小：虽然只需1位，但占用完整的32字节存储槽
    // - 可能值：true（真）或false（假），默认值为false
    // - 逻辑运算：支持 && (与)、|| (或)、! (非)
    // - 短路求值：&& 和 || 支持短路运算，可以优化gas消耗
    // - 比较运算：支持 == (等于) 和 != (不等于)
    // - 条件控制：常用于if语句、while循环、require检查
    // - Gas效率：读取和写入成本与其他基本类型相同
    // - 打包优化：可以与其他小类型打包在同一存储槽中
    // - 使用场景：开关状态、权限标识、条件判断等
    // - 注意事项：避免不必要的状态变更以节省gas
    
    // ========== 整数类型变种 (Integer Type Variants) ==========
    uint8 public smallNumber;     
    // 8位无符号整数详解：
    // - 数值范围：0 到 255（2^8 - 1）
    // - 存储优化：占用1字节，可与其他小类型打包在同一32字节槽中
    // - 使用场景：枚举值、状态标识、百分比、年龄等小范围数值
    // - 打包示例：32个uint8可以共享一个存储槽
    // - 类型转换：需要显式转换到更大的整数类型
    // - 算术操作：运算前会被提升到uint256，结果需要强制转换回uint8
    // - Gas节省：读取时如果与其他变量打包，可能需要额外的位操作
    // - 溢出保护：Solidity 0.8+同样提供溢出检查
    
    uint128 public mediumNumber;  
    // 128位无符号整数详解：
    // - 数值范围：0 到 340282366920938463463374607431768211455（2^128 - 1）
    // - 存储优化：两个uint128变量可以打包在一个32字节存储槽中
    // - 精度平衡：在存储效率和数值范围之间的良好平衡
    // - 使用场景：大额代币数量、时间戳、哈希值的一部分
    // - 打包策略：与另一个uint128或多个小类型组合使用
    // - 类型安全：需要显式转换到uint256进行某些操作
    // - Gas考虑：打包存储时写入可能更昂贵，但存储成本降低
    // - 算术运算：与uint8类似，运算时会提升到uint256
    
    int256 public signedNumber;   
    // 256位有符号整数详解：
    // - 数值范围：-57896044618658097711785492504343953926634992332820282019728792003956564819968 
    //            到 57896044618658097711785492504343953926634992332820282019728792003956564819967
    // - 二进制表示：使用二进制补码表示负数
    // - 存储需求：完整的32字节存储槽
    // - 算术运算：支持加减乘除、取模、幂运算，包括负数运算
    // - 比较运算：支持所有比较操作，包括负数比较
    // - 默认值：0（既不是正数也不是负数）
    // - 溢出处理：下溢和上溢都会触发异常
    // - 使用场景：需要表示负值的场景，如温度、坐标、差值计算
    // - 类型转换：可以与uint256相互转换，但需要注意符号位
    
    // ========== 字节类型 (Bytes Types) ==========
    bytes32 public fixedBytes;    
    // 固定长度字节类型详解：
    // - 数据长度：固定32字节（256位）
    // - 存储方式：占用一个完整的存储槽，右对齐填充
    // - Gas效率：比动态bytes类型更节省gas
    // - 常见用途：存储哈希值（如keccak256结果）、密钥、签名
    // - 操作支持：位运算（&, |, ^）、索引访问、长度固定
    // - 比较运算：支持直接比较（==, !=）
    // - 类型安全：不能直接转换为string，需要特殊处理
    // - 优化建议：当字节长度已知且固定时，优先选择bytesN类型
    // - 安全性：适合存储敏感数据的哈希值
    
    bytes1 public singleByte;     
    // 单字节类型详解：
    // - 数据长度：固定1字节（8位）
    // - 存储布局：占用完整32字节槽，但只使用最左边1字节
    // - 打包潜力：可以与其他小类型打包存储以优化gas
    // - 使用场景：状态标识、简单枚举、标志位组合
    // - 位操作：支持按位与（&）、或（|）、异或（^）、非（~）
    // - 索引访问：可以通过[0]访问唯一字节
    // - 类型系列：bytes1到bytes32都是可用的固定长度类型
    // - 转换规则：可以转换为更大的bytesN类型，但不能转换为更小的
    // - 比较操作：支持相等（==）和不等（!=）比较
    
    bytes public dynamicBytes;    
    // 动态字节数组详解：
    // - 数据结构：长度可变的字节序列
    // - 存储模式：长度存储在主槽，数据存储在keccak256(slot)开始的位置
    // - Gas消耗：基于实际长度计算，每个字节消耗额外gas
    // - 使用场景：二进制数据、编码后的复杂数据结构、可变长度消息
    // - 与string区别：bytes用于任意二进制数据，string用于UTF-8文本
    // - 操作方法：push()添加字节、pop()移除最后字节、length获取长度
    // - 索引访问：支持通过索引读写单个字节
    // - 内存效率：在memory中比storage中操作更高效
    // - 类型转换：可以与string相互转换，但需要显式转换
    
    // ============ 映射 (Mapping) ============
    // 映射是Solidity中的核心数据结构，实现键值对的高效存储和检索
    // 
    // 核心特性：
    // - 存储原理：使用keccak256(key . slot)计算存储位置
    // - 无序结构：不维护插入顺序，无法遍历所有键
    // - 键唯一性：每个键只能对应一个值
    // - 默认值：未设置的键返回类型的默认值（如uint256返回0，bool返回false）
    // - Gas效率：O(1)时间复杂度，读写操作gas消耗固定
    // - 存储成本：每个键值对占用一个存储槽（20,000 gas首次写入）
    // - 删除操作：设置为默认值可以获得gas退款
    
    mapping(address => uint256) public balances;    
    // 地址余额映射详解：
    // - 键类型：address（20字节）- 以太坊账户或合约地址
    // - 值类型：uint256（32字节）- 余额数量，支持大额数值
    // - 存储位置：keccak256(address . slot)确定每个余额的存储槽
    // - 默认行为：新地址自动返回0余额，无需初始化
    // - 常见操作：查询余额、增加余额、减少余额、转账检查
    // - Gas消耗：读取800 gas，首次写入20,000 gas，修改5,000 gas
    // - 安全考虑：注意整数溢出和下溢保护
    // - 实际应用：代币余额、积分系统、存款记录
    
    mapping(address => bool) public authorized;     
    // 地址授权映射详解：
    // - 键类型：address（20字节）- 用户或合约地址
    // - 值类型：bool（1字节，但占用32字节槽）- 授权状态标识
    // - 默认值：false - 新地址默认未授权，安全设计
    // - 存储位置：keccak256(address . slot)计算每个授权状态存储位置
    // - 使用场景：权限控制、白名单管理、访问控制、管理员权限
    // - 安全考虑：默认拒绝策略，需要显式授权
    // - Gas效率：布尔值操作成本低，查询和修改都很高效
    // - 常见操作：授权用户、撤销权限、检查权限状态
    // - 实际应用：多重签名、角色管理、功能访问控制
    
    // ========== 嵌套映射 (Nested Mapping) ==========
    mapping(address => mapping(uint256 => bool)) public nestedMapping;  
    // 嵌套映射详解：
    // - 数据结构：二维映射，mapping的值也是mapping
    // - 键层次：第一层address（用户），第二层uint256（ID或索引）
    // - 值类型：bool（权限或状态标识）
    // - 存储原理：keccak256(keccak256(address . outerSlot) . uint256)
    // - 访问语法：nestedMapping[user][id]
    // - 默认值：两层都未设置时返回false
    // - 使用场景：用户多权限管理、用户多资产授权、复杂权限矩阵
    // - Gas消耗：两次哈希计算，但仍然是O(1)时间复杂度
    // - 实际应用：ERC721代币授权、多级权限系统、用户资源访问控制
    // - 优势：支持复杂的多维数据关系，保持高效访问
    
    // ========== 映射到结构体 (Mapping to Struct) ==========
    mapping(address => Person) public personData;   
    // 映射到结构体详解：
    // - 键类型：address（用户唯一标识）
    // - 值类型：Person结构体（复合数据类型）
    // - 存储布局：结构体字段分布在连续的存储槽中
    // - 访问方式：personData[address].fieldName
    // - 自动getter：public修饰符为每个结构体字段生成独立的getter函数
    // - 默认值：结构体所有字段都是默认值（string为""，uint为0，bool为false等）
    // - 使用场景：用户档案管理、复杂实体数据存储、一对一关系映射
    // - Gas优化：相关数据打包存储，减少存储槽使用
    // - 实际应用：用户信息系统、资产管理、身份验证系统
    // - 优势：类型安全、数据结构化、便于管理和查询
    
    // ============ 数组 (Arrays) ============
    // 数组是Solidity中的重要数据结构，支持有序数据的存储和操作
    // 
    // 核心特性：
    // - 有序存储：元素按索引顺序排列，支持位置访问
    // - 可遍历性：支持循环遍历所有元素，便于批量操作
    // - 索引访问：O(1)时间复杂度的随机访问
    // - 动态扩容：动态数组长度可变，支持添加和删除元素
    // - 类型安全：所有元素必须是相同类型
    // 
    // 存储机制：
    // - 动态数组：第一个槽存储长度，后续槽存储元素
    // - 固定数组：连续存储，不需要长度信息
    // - 存储位置：动态数组元素存储在keccak256(slot)开始的位置
    
    uint256[] public numbers;     
    // 动态数字数组详解：
    // - 元素类型：uint256（32字节无符号整数）
    // - 长度管理：自动维护length属性，随添加/删除更新
    // - 存储布局：length存储在主槽，元素从keccak256(slot)开始连续存储
    // - 支持操作：push()添加元素、pop()移除末尾元素、delete清零元素
    // - 索引范围：0到length-1，越界访问会抛出异常
    // - Gas消耗：push操作约20,000-40,000 gas，取决于是否需要扩容
    // - 遍历复杂度：O(n)，大数组遍历可能超过gas限制
    // - 使用场景：数字列表、计数序列、动态数据集合
    // - 安全考虑：避免无限增长，防止gas限制攻击
    
    address[] public users;       
    // 用户地址数组详解：
    // - 元素类型：address（20字节以太坊地址）
    // - 数据用途：维护用户列表，支持用户管理和批量操作
    // - 存储优化：每个地址占用32字节槽（地址只用20字节，剩余12字节浪费）
    // - 遍历功能：支持循环遍历所有注册用户
    // - 查重考虑：数组不自动去重，需要额外逻辑防止重复添加
    // - 查找复杂度：O(n)线性查找，大量用户时效率较低
    // - Gas风险：数组过大时遍历可能超出gas限制
    // - 实际应用：用户注册列表、白名单管理、投票参与者列表
    // - 优化建议：配合mapping使用提高查找效率
    // - 删除策略：删除中间元素需要谨慎处理索引变化
    
    // ========== 固定长度数组 (Fixed-Size Arrays) ==========
    uint256[5] public fixedArray;  
    // 固定长度数组详解：
    // - 数组大小：编译时确定，包含5个uint256元素
    // - 存储布局：5个连续的32字节存储槽，无需长度信息
    // - 内存效率：比动态数组节省一个长度存储槽
    // - Gas可预测：操作成本固定，便于gas估算
    // - 访问安全：编译时和运行时都有边界检查
    // - 初始化：所有元素默认为0
    // - 不可扩容：长度固定，不支持push/pop操作
    // - 使用场景：已知大小的数据集、配置参数、固定维度的向量
    // - 优势：存储效率高、访问速度快、gas消耗可预测
    // - 限制：灵活性较差，无法动态调整大小
    
    // ========== 多维数组 (Multi-dimensional Arrays) ==========
    uint256[][] public matrix;    
    // 二维动态数组详解：
    // - 数据结构：数组的数组，支持不规则矩阵（每行长度可不同）
    // - 存储复杂性：外层数组存储内层数组的存储位置引用
    // - 内存布局：每个内层数组独立存储，通过引用连接
    // - 访问语法：matrix[row][col]进行二维索引访问
    // - 动态扩容：外层和内层数组都可以独立扩容
    // - Gas消耗：比一维数组更高，需要多次间接访问
    // - 不规则支持：不同行可以有不同的列数
    // - 使用场景：矩阵运算、表格数据、二维网格、复杂数据结构
    // - 初始化：需要逐级初始化，外层数组和每个内层数组
    // - 注意事项：深度越大，gas消耗和复杂度越高
    
    // ========== 字节数组 (Bytes Arrays) ==========
    bytes32[] public hashList;    
    // 哈希值数组详解：
    // - 元素类型：bytes32（32字节固定长度哈希值）
    // - 存储特性：每个哈希值占用一个完整存储槽
    // - 常见用途：存储交易哈希、文件哈希、Merkle树节点、数字签名
    // - 访问效率：固定长度元素，索引访问性能优异
    // - 哈希兼容：与keccak256、sha256等哈希函数输出兼容
    // - 比较操作：支持直接相等比较，无需哈希
    // - Gas效率：比动态bytes数组更节省gas
    // - 安全存储：适合存储密码学数据，不会被误修改
    // - 实际应用：区块链数据验证、数据完整性校验、密钥管理
    // - 批量操作：支持批量哈希验证和处理
    
    // ============ 结构体 (Structs) ============
    // 结构体是用户自定义的复合数据类型，将相关数据组织在一起
    // 
    // 核心特性：
    // - 自定义类型：开发者定义的数据结构，组合多个不同类型的字段
    // - 值类型：赋值时进行深拷贝，修改副本不影响原始数据
    // - 内存引用：支持memory、storage和calldata引用类型
    // - 字段访问：通过点号语法访问成员变量
    // - 存储优化：编译器自动优化字段存储布局以节省gas
    // 
    // 存储布局：
    // - 顺序存储：按声明顺序分配存储槽
    // - 打包优化：小类型字段可以共享同一个32字节槽
    // - 对齐规则：遵循存储槽边界对齐，避免跨槽存储
    
    struct Person {
        string name;              
        // 姓名字段详解：
        // - 数据类型：动态长度UTF-8字符串
        // - 存储特性：字符串单独占用存储槽，长度信息和数据分离存储
        // - 编码方式：UTF-8编码，支持多语言字符
        // - Gas影响：按字符串长度收费，长字符串消耗更多gas
        // - 默认值：空字符串""
        // - 使用建议：避免过长的字符串以节省gas
        
        uint256 age;              
        // 年龄字段详解：
        // - 数据类型：256位无符号整数
        // - 存储占用：完整的32字节存储槽
        // - 数值范围：0到2^256-1（理论上支持极大年龄值）
        // - 实际使用：通常用uint8即可满足年龄需求
        // - 默认值：0
        // - 优化建议：考虑使用uint8以便与其他字段打包
        
        bool isRegistered;        
        // 注册状态详解：
        // - 数据类型：布尔值（true/false）
        // - 存储大小：虽然只需1位，但在独立存储时占用32字节
        // - 打包潜力：可以与address和uint8字段共享存储槽
        // - 默认值：false（未注册状态）
        // - 逻辑意义：标识用户是否已完成注册流程
        
        address wallet;           
        // 钱包地址详解：
        // - 数据类型：以太坊地址（20字节）
        // - 存储优化：与bool和uint8字段可以打包在同一槽中
        // - 地址用途：用户的以太坊钱包地址，用于转账和身份验证
        // - 默认值：零地址（0x0000000000000000000000000000000000000000）
        // - 安全考虑：确保地址有效性，避免转账到零地址
        
        uint8 level;              
        // 等级字段详解：
        // - 数据类型：8位无符号整数（0-255）
        // - 存储优化：与bool(1字节)和address(20字节)打包存储
        // - 打包计算：bool(1) + address(20) + uint8(1) = 22字节 < 32字节槽
        // - 使用场景：用户等级、权限级别、经验等级等
        // - 数值范围：足够表示大多数等级系统
        // - 默认值：0（初始等级）
    }
    // 
    // 存储布局分析：
    // 槽0：string name（动态长度，独立存储）
    // 槽1：uint256 age（完整32字节）
    // 槽2：bool isRegistered + address wallet + uint8 level（打包存储）
    // 
    // Gas优化：
    // - 字段重排序可以减少存储槽使用量
    // - 相关字段放在一起可以减少storage读取次数
    // - 固定长度字段优先于动态长度字段
    
    // ========== 嵌套结构体 (Nested Structs) ==========
    struct Company {
        string companyName;       
        // 公司名称详解：
        // - 数据类型：动态长度字符串
        // - 存储模式：独立存储槽，支持任意长度的公司名称
        // - 编码格式：UTF-8编码，支持国际化公司名称
        // - Gas消耗：按字符数计算，建议控制在合理长度内
        // - 业务用途：公司标识、显示名称、法律实体名称
        
        Person[] employees;       
        // 员工数组详解：
        // - 数据类型：Person结构体的动态数组
        // - 嵌套复杂性：数组中每个元素都是完整的Person结构体
        // - 存储布局：数组长度存储在一个槽，元素连续存储在后续槽中
        // - Gas考虑：添加员工需要分配多个存储槽（Person结构体的所有字段）
        // - 扩容成本：随着员工数量增加，遍历和管理成本上升
        // - 查询复杂度：查找特定员工需要O(n)时间复杂度
        // - 实际应用：员工管理、组织架构、人员名册
        // - 优化建议：配合mapping使用以提高查询效率
        
        mapping(address => bool) isEmployee;  
        // 员工身份映射详解：
        // - 数据类型：地址到布尔值的映射
        // - 功能作用：快速验证某个地址是否为公司员工
        // - 查询效率：O(1)时间复杂度，比数组遍历快得多
        // - 与数组协作：与employees数组配合使用，提供不同的访问模式
        // - 默认值：false，新地址默认不是员工
        // - 权限控制：可用于基于员工身份的权限管理
        // - 数据一致性：需要确保与employees数组保持同步
        // - 实际应用：员工权限验证、快速身份检查、访问控制
        
        uint256 foundedYear;      
        // 成立年份详解：
        // - 数据类型：256位无符号整数
        // - 数值范围：理论上支持极大的年份值
        // - 实际使用：通常使用uint16即可满足年份需求（0-65535）
        // - 存储占用：完整的32字节存储槽
        // - 业务意义：公司成立时间，用于计算公司历史、资质等
        // - 验证逻辑：应该验证年份的合理性（不能是未来年份）
        // - 优化机会：可以与其他小类型字段打包存储
    }
    // 
    // 嵌套结构体特性分析：
    // - 复合数据：结构体可以包含其他结构体、数组、映射等复杂类型
    // - 存储复杂性：嵌套层次越深，存储和访问成本越高
    // - 数据关联：支持复杂的数据关系建模
    // - 内存引用：可以创建指向storage的引用，避免数据拷贝
    // - Gas优化：合理设计数据结构可以显著降低gas消耗
    // - 业务建模：能够准确反映现实世界的复杂业务关系
    // 
    // 使用建议：
    // - 避免过深的嵌套层次
    // - 合理使用mapping和array的组合
    // - 注意数据一致性维护
    // - 考虑查询和更新的效率平衡
    
    // ============ 枚举 (Enums) ============
    // 枚举是用户定义的类型，用于创建有限的命名选项集合
    // 
    // 核心特性：
    // - 类型安全：编译时检查，只能赋值有效的枚举选项
    // - 整数索引：内部以uint8形式存储（如果选项少于256个）
    // - 零基索引：第一个选项索引为0，依次递增
    // - 不可扩展：部署后无法添加新选项
    // - 内存高效：比字符串更节省存储空间
    // - 可读性强：代码更清晰，避免使用魔法数字
    // 
    // 存储优化：
    // - 小枚举（<256选项）：存储为uint8，可与其他小类型打包
    // - 大枚举：自动提升到uint16或更大类型
    // - 默认值：总是第一个枚举选项（索引0）
    
    enum Status { Pending, Active, Inactive }  
    // 状态枚举详解：
    // - 选项定义：Pending(0)、Active(1)、Inactive(2)
    // - 存储类型：uint8（3个选项，远少于256）
    // - 使用场景：合约状态管理、用户状态跟踪、订单状态等
    // - 状态转换：通常有特定的状态转换规则
    //   * Pending -> Active（激活）
    //   * Active -> Inactive（停用）
    //   * Inactive -> Active（重新激活）
    // - 业务逻辑：不同状态对应不同的业务行为
    // - 默认状态：Pending（索引0），表示初始/等待状态
    // - 类型转换：可以与uint8相互转换，但需要显式转换
    // - 比较操作：支持 ==、!= 比较，不支持 <、> 比较
    // - 实际应用：工作流状态、审批流程、生命周期管理
    
    Status public currentStatus;                
    // 当前状态变量详解：
    // - 数据类型：Status枚举类型
    // - 默认值：Status.Pending（第一个枚举选项）
    // - 存储优化：作为uint8存储，可与其他小类型打包
    // - 访问控制：通常配合修饰符控制状态转换权限
    // - 状态查询：外部可以查询当前合约状态
    // - 事件记录：状态变更时通常需要记录事件
    // - 业务含义：代表整个合约或特定功能的当前状态
    
    // ========== 更多枚举示例 (Additional Enum Examples) ==========
    enum Priority { Low, Medium, High, Critical }  
    // 优先级枚举详解：
    // - 选项定义：Low(0)、Medium(1)、High(2)、Critical(3)
    // - 存储类型：uint8（4个选项）
    // - 业务含义：
    //   * Low：低优先级，非紧急任务
    //   * Medium：中等优先级，常规任务
    //   * High：高优先级，重要任务
    //   * Critical：紧急优先级，需要立即处理
    // - 排序语义：虽然不支持直接比较，但索引值反映优先级高低
    // - 实际应用：任务管理、工单系统、资源分配、风险评估
    // - 扩展性：可以轻松添加新的优先级（重新部署时）
    // - 算法应用：可用于优先队列、排序算法等
    
    enum UserRole { Guest, User, Admin, SuperAdmin }  
    // 用户角色枚举详解：
    // - 选项定义：Guest(0)、User(1)、Admin(2)、SuperAdmin(3)
    // - 权限层次：索引值越高，权限越大
    // - 角色说明：
    //   * Guest：访客，最低权限，只能查看公开信息
    //   * User：普通用户，基本操作权限
    //   * Admin：管理员，高级管理权限
    //   * SuperAdmin：超级管理员，最高权限
    // - 权限继承：高级角色通常包含低级角色的所有权限
    // - 安全设计：默认Guest角色，需要显式提升权限
    // - 实际应用：用户权限管理、访问控制、功能限制
    // - 检查模式：可以通过 >= 逻辑检查权限级别
    
    Priority public taskPriority;   
    // 任务优先级变量详解：
    // - 数据类型：Priority枚举
    // - 默认值：Priority.Low（索引0）
    // - 业务用途：标识当前任务或操作的重要程度
    // - 决策依据：系统可根据优先级分配资源和处理顺序
    // - 状态管理：可以动态调整任务优先级
    // - 查询接口：外部可以查询当前任务优先级
    
    UserRole public userRole;       
    // 用户角色变量详解：
    // - 数据类型：UserRole枚举
    // - 默认值：UserRole.Guest（最低权限）
    // - 权限控制：决定用户可以执行的操作范围
    // - 安全策略：默认最低权限，需要明确授权提升
    // - 角色转换：通常需要权限验证才能修改
    // - 访问检查：函数修饰符可以基于角色控制访问
    
    // ============ 事件 (Events) ============
    // 事件是Solidity中的重要机制，用于记录区块链上的重要活动
    // 
    // 核心特性：
    // - 日志记录：将数据写入区块链日志，永久存储且不可篡改
    // - 低成本：比状态变量存储便宜很多，适合记录大量数据
    // - 外部监听：前端DApp可以监听事件，实现实时通知
    // - 历史查询：可以查询历史事件，追踪数据变化
    // - 过滤支持：indexed参数支持高效的事件过滤
    // - 不占存储：事件数据不占用合约存储空间
    // 
    // Gas成本：
    // - 基础成本：每个事件约375 gas
    // - 数据成本：每字节约8 gas
    // - indexed成本：每个indexed参数额外375 gas
    // - 总体：比storage存储便宜10-100倍
    
    event MessageChanged(string oldMessage, string newMessage);  
    // 消息变更事件详解：
    // - 参数类型：两个string类型参数
    // - 数据记录：记录消息变更的前后值
    // - 审计追踪：提供完整的消息修改历史
    // - Gas消耗：按字符串长度计算，长消息成本较高
    // - 监听用途：前端可以监听此事件更新UI显示
    // - 历史查询：可以查询所有历史消息变更记录
    // - 无索引：参数无indexed修饰，查询时需要扫描所有事件
    // - 实际应用：配置变更记录、内容修改日志、系统通知
    // - 最佳实践：包含足够的上下文信息便于理解和调试
    
    event UserAdded(address indexed user, uint256 timestamp);    
    // 用户添加事件详解：
    // - indexed参数：address user使用indexed修饰
    // - 索引优势：可以高效过滤特定用户的事件
    // - 查询效率：indexed参数支持O(log n)查询复杂度
    // - 时间戳：记录用户添加的确切时间
    // - 过滤语法：web3.js可以使用 {user: "0x..."} 过滤
    // - 索引限制：最多3个参数可以使用indexed
    // - Gas成本：indexed参数比普通参数稍贵
    // - 实际应用：用户注册通知、权限变更记录、活动追踪
    // - 前端集成：DApp可以监听此事件更新用户列表
    // - 数据分析：便于统计用户增长趋势和活跃度
    
    // ============ 修饰符 (Modifiers) ============
    // 修饰符是Solidity中的重要机制，用于函数的预处理和权限控制
    // 
    // 核心特性：
    // - 代码重用：避免在多个函数中重复相同的检查逻辑
    // - 权限控制：实现细粒度的访问控制和权限管理
    // - 条件检查：在函数执行前进行必要的条件验证
    // - 执行控制：控制函数的执行流程和时机
    // - 组合使用：多个修饰符可以组合使用，增强安全性
    // 
    // 执行机制：
    // - 预执行：修饰符代码在函数体之前执行
    // - 占位符：_; 表示函数体执行位置
    // - 失败回滚：require失败会回滚整个交易
    // - Gas消耗：修饰符逻辑也会消耗gas
    // - 嵌套支持：支持修饰符的嵌套调用
    
    /**
     * @dev 只有合约所有者才能调用的修饰符
     * 实现基于所有者的访问控制机制
     * 
     * 安全特性：
     * - 身份验证：通过msg.sender验证调用者身份
     * - 权限检查：只允许合约部署者（所有者）执行特权操作
     * - 失败处理：权限验证失败时自动回滚交易
     * - Error信息：提供清晰的错误提示信息
     * 
     * 使用场景：
     * - 管理员功能：修改合约配置、升级合约状态
     * - 权限分配：添加或移除其他管理员
     * - 紧急操作：暂停合约、提取资金等
     * - 系统维护：调整参数、清理数据等
     * 
     * Gas消耗：
     * - require检查：约2300 gas
     * - 地址比较：约3 gas
     * - 字符串错误：按消息长度计算
     */
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this function");
        _;  
        // 下划线占位符详解：
        // - 执行时机：修饰符检查通过后，在此位置执行函数体
        // - 流程控制：可以在_之前和之后添加额外逻辑
        // - 返回处理：函数返回值会正常传递
        // - 异常传播：函数体异常会向上传播
    }
    
    /**
     * @dev 只有在合约激活状态下才能调用的修饰符
     * 实现基于状态的访问控制机制
     * 
     * 状态管理特性：
     * - 状态检查：验证合约当前是否处于激活状态
     * - 业务逻辑：确保只有在合约正常运行时才能执行特定操作
     * - 安全机制：提供合约暂停/恢复功能的基础
     * - 条件控制：通过布尔变量控制函数可用性
     * 
     * 使用场景：
     * - 业务功能：只有在合约激活时才允许正常业务操作
     * - 维护模式：合约维护期间暂停用户操作
     * - 紧急停止：发现问题时快速暂停所有操作
     * - 渐进启动：合约部署后分阶段开放功能
     * 
     * 组合使用：
     * - 可与onlyOwner组合：function func() onlyOwner whenActive
     * - 执行顺序：按修饰符声明顺序依次检查
     * - 短路机制：任一修饰符失败都会回滚交易
     */
    modifier whenActive() {
        require(isActive, "Contract is not active");
        _;
    }
    // 修饰符组合特性：
    // - 多重检查：多个修饰符提供多层安全保护
    // - 顺序执行：从左到右依次执行修饰符检查
    // - 逻辑与：所有修饰符都通过才能执行函数体
    // - 失败回滚：任何一个修饰符失败都会回滚整个交易
    
    // ============ 构造函数 (Constructor) ============
    /**
     * @dev 构造函数 - 合约部署时的初始化函数
     * @param _initialMessage 初始消息内容
     * 
     * 构造函数特性：
     * - 执行时机：仅在合约部署时执行一次，无法再次调用
     * - 初始化作用：设置合约的初始状态和配置
     * - 参数传递：可以接收部署时传入的参数
     * - 权限设置：通常在此设置合约所有者
     * - 状态初始化：为状态变量赋予初始值
     * 
     * Gas消耗分析：
     * - 部署成本：构造函数执行成本包含在合约部署gas中
     * - 存储写入：每个状态变量初始化约20,000 gas
     * - 参数处理：复杂参数（如string）会增加gas消耗
     * - 总成本：通常占合约部署总成本的10-30%
     * 
     * 安全考虑：
     * - 参数验证：对输入参数进行必要的验证
     * - 权限初始化：确保正确设置初始权限
     * - 状态一致性：确保所有相关状态变量都正确初始化
     */
    constructor(string memory _initialMessage) {
        message = _initialMessage;           
        // 初始消息设置详解：
        // - 参数来源：从部署交易中传入的字符串参数
        // - 存储位置：storage存储，永久保存在区块链上
        // - Memory优化：_initialMessage使用memory参数，减少gas消耗
        // - 编码处理：自动处理UTF-8编码和长度计算
        // - Gas成本：按字符串长度计算，长消息成本较高
        
        owner = msg.sender;                  
        // 所有者设置详解：
        // - msg.sender：获取当前交易的发送者（部署者）地址
        // - 权限基础：为后续的权限控制提供基础
        // - 安全设计：只有部署者拥有最高权限
        // - 不可变性：通常所有者在构造函数中设置后不再更改
        // - 特权操作：后续的管理员函数都基于此地址验证
        
        count = 0;                          
        // 计数器初始化详解：
        // - 显式初始化：虽然uint256默认值为0，但显式设置更清晰
        // - 状态管理：为后续的计数操作提供起始点
        // - Gas消耗：首次写入非零值到零值槽位，消耗20,000 gas
        // - 业务含义：表示合约部署时的操作计数起点
        
        isActive = true;                    
        // 激活状态设置详解：
        // - 默认值覆盖：bool默认值为false，这里显式设为true
        // - 功能控制：影响带whenActive修饰符的函数可用性
        // - 部署策略：合约部署后立即可用，无需额外激活步骤
        // - 业务逻辑：表示合约已准备好接受用户操作
        
        currentStatus = Status.Active;       
        // 状态枚举设置详解：
        // - 枚举赋值：设置为Active状态而不是默认的Pending
        // - 状态机：定义合约的初始状态节点
        // - 业务流程：跳过Pending阶段，直接进入Active状态
        // - 后续操作：影响基于状态的业务逻辑判断
        
        // ========== 初始化新增的基本数据类型 ==========
        smallNumber = 100;                   
        // 8位整数初始化详解：
        // - 数值选择：100在uint8范围内（0-255），安全且有意义
        // - 存储打包：与其他小类型字段可以共享存储槽
        // - 示例用途：可能代表百分比、等级、年龄等小范围数值
        // - Gas优化：与其他字段打包时可以减少存储成本
        
        mediumNumber = 50000;                
        // 128位整数初始化详解：
        // - 数值选择：50000展示中等范围数值的使用
        // - 存储效率：两个uint128可以共享一个存储槽
        // - 应用场景：代币数量、时间戳、大额计数等
        // - 精度平衡：在存储效率和数值范围间的良好平衡
        
        signedNumber = -12345;               
        // 有符号整数初始化详解：
        // - 负数演示：展示Solidity对负数的支持
        // - 二进制表示：使用二进制补码存储负数
        // - 应用场景：温度、坐标、差值等需要负数的计算
        // - 类型安全：编译器确保类型匹配和范围检查
        
        fixedBytes = "Hello Solidity!";      
        // 固定字节初始化详解：
        // - 字符串转换：Solidity自动将字符串字面量转换为bytes32
        // - 长度处理：字符串长度小于32字节时右侧填充零
        // - UTF-8编码：支持UTF-8字符，但按字节存储
        // - 哈希用途：常用于存储哈希值、密钥等固定长度数据
        
        singleByte = 0xFF;                   
        // 单字节初始化详解：
        // - 十六进制表示：0xFF表示255（最大的uint8值）
        // - 位模式：11111111（所有位都是1）
        // - 常见用途：状态标识、掩码操作、标志位组合
        // - 打包潜力：可与address和bool一起打包存储
        
        dynamicBytes = "Dynamic bytes data"; 
        // 动态字节初始化详解：
        // - 长度可变：与固定字节不同，长度随内容调整
        // - 存储模式：长度和数据分开存储
        // - 编码灵活：支持任意长度的二进制数据
        // - Gas成本：按实际数据长度计算存储成本
        
        // ========== 初始化枚举 ==========
        taskPriority = Priority.Medium;      
        // 任务优先级初始化详解：
        // - 中等优先级：选择Medium而不是默认的Low，体现初始重要性
        // - 枚举赋值：编译时类型检查确保只能赋值有效选项
        // - 业务逻辑：新合约的任务通常具有中等重要性
        // - 后续调整：可以通过专门函数动态调整优先级
        
        userRole = UserRole.Admin;           
        // 用户角色初始化详解：
        // - 管理员权限：部署者默认获得管理员权限
        // - 权限设计：高于普通用户，低于超级管理员
        // - 安全考虑：避免直接设为SuperAdmin，提供权限升级路径
        // - 角色管理：为后续的权限控制和角色转换提供基础
        
        // ========== 初始化固定数组 ==========
        fixedArray[0] = 10;                  
        // 固定数组初始化详解：
        // - 索引访问：通过数组索引直接赋值
        // - 边界安全：编译器确保索引不超出数组边界
        // - 连续存储：数组元素在存储中连续排列
        // - 初始模式：展示有序数据的初始化方法
        
        fixedArray[1] = 20;
        fixedArray[2] = 30;
        // 注意：fixedArray[3]和fixedArray[4]保持默认值0
        // 
        // 数组初始化策略：
        // - 部分初始化：只初始化需要的元素，其余保持默认值
        // - 性能考虑：避免不必要的初始化以节省gas
        // - 数据模式：展示递增序列，便于后续操作验证
        // - 扩展空间：保留未初始化位置供后续使用
    }
    // 构造函数执行完成后的合约状态：
    // - 所有状态变量已正确初始化
    // - 合约地址已分配并可接收调用
    // - 权限体系已建立（owner设置）
    // - 业务逻辑已准备就绪（isActive=true）
    // - 示例数据已加载，便于功能测试和演示
    
    // ============ 公共函数 (Public Functions) ============
    // 公共函数是合约的主要接口，外部用户和其他合约可以调用
    // 
    // 函数特性：
    // - 外部可见：任何人都可以调用（除非有修饰符限制）
    // - 状态修改：可以读取和修改合约状态
    // - Gas消耗：调用者支付gas费用
    // - 交易包含：每次调用都是一个区块链交易
    // - 权限控制：通过修饰符实现访问控制
    // 
    // 设计原则：
    // - 输入验证：对所有参数进行必要的验证
    // - 状态一致性：确保操作后合约状态保持一致
    // - 事件记录：重要操作应该触发事件
    // - Gas效率：优化代码以减少gas消耗
    // - 安全考虑：防止重入攻击和其他安全问题
    
    /**
     * @dev 设置新的消息内容（仅限合约所有者）
     * @param _newMessage 新的消息内容
     * 
     * 功能详解：
     * - 权限控制：使用onlyOwner修饰符限制访问权限
     * - 状态修改：更新合约的核心消息状态
     * - 事件记录：记录消息变更的完整历史
     * - 参数优化：使用memory参数减少gas消耗
     * 
     * 执行流程：
     * 1. onlyOwner修饰符验证调用者身份
     * 2. 保存当前消息作为历史记录
     * 3. 更新消息为新内容
     * 4. 触发MessageChanged事件
     * 
     * Gas消耗分析：
     * - 权限检查：约2,300 gas
     * - 存储读取（旧消息）：约800 gas
     * - 存储写入（新消息）：约5,000-20,000 gas（取决于是否首次写入）
     * - 事件记录：约375 gas + 数据成本
     * - 总计：约8,000-25,000 gas（取决于消息长度和存储状态）
     * 
     * 安全考虑：
     * - 访问控制：只有所有者可以修改核心消息
     * - 数据完整性：保留完整的变更历史
     * - 审计支持：通过事件提供可追溯的修改记录
     */
    function setMessage(string memory _newMessage) public onlyOwner {
        string memory oldMessage = message;  
        // 历史记录保存详解：
        // - Memory存储：临时存储旧消息，避免重复的storage读取
        // - 事件参数：为事件记录提供变更前的值
        // - Gas优化：一次性读取，避免多次storage访问
        // - 审计追踪：确保变更历史的完整性
        
        message = _newMessage;               
        // 消息更新详解：
        // - Storage写入：将新消息永久存储到区块链
        // - 状态变更：改变合约的核心状态
        // - Gas消耗：根据字符串长度和存储状态计算成本
        // - 原子操作：与事件记录形成原子性的状态变更
        
        emit MessageChanged(oldMessage, _newMessage);  
        // 事件触发详解：
        // - 历史记录：完整记录消息变更的前后状态
        // - 外部监听：前端应用可以监听此事件更新界面
        // - 审计日志：提供不可篡改的操作记录
        // - 查询支持：支持历史变更的查询和分析
    }
    // 函数完成后的状态：
    // - 消息已更新为新内容
    // - 变更历史已记录到区块链日志
    // - 外部监听者已收到变更通知
    // - 合约状态保持一致性
    
    /**
     * @dev 获取当前消息内容（只读函数）
     * @return 当前存储的消息内容
     * 
     * View函数特性：
     * - 只读操作：不修改任何合约状态
     * - 免费调用：本地调用时不消耗gas
     * - 实时数据：返回当前最新的消息内容
     * - 无副作用：不会产生交易或状态变更
     * 
     * 调用方式：
     * - 本地调用：通过web3.js的call方法，免费且即时
     * - 交易调用：通过send方法调用会消耗gas但无意义
     * - 合约调用：其他合约可以直接调用获取数据
     * 
     * 返回值处理：
     * - 字符串类型：返回完整的UTF-8编码字符串
     * - 动态长度：支持任意长度的消息内容
     * - 编码格式：前端需要正确解码UTF-8字符串
     * 
     * 使用场景：
     * - 前端显示：在用户界面显示当前消息
     * - 状态查询：其他合约查询当前状态
     * - 数据验证：验证消息是否符合预期
     * - 历史对比：与历史数据进行对比分析
     */
    function getMessage() public view returns (string memory) {
        return message;
    }
    // View函数优势：
    // - 性能优异：本地执行，响应速度快
    // - 成本为零：不产生区块链交易费用
    // - 数据准确：直接从区块链状态读取
    // - 并发安全：多个查询可以同时进行
    
    /**
     * @dev 增加计数器（仅在合约激活时可调用）
     * 
     * 功能详解：
     * - 状态检查：使用whenActive修饰符确保合约处于激活状态
     * - 计数操作：对全局计数器执行原子性递增操作
     * - 溢出保护：Solidity 0.8+自动检查整数溢出
     * - 公开访问：任何人都可以调用（在激活状态下）
     * 
     * 修饰符作用：
     * - whenActive：确保isActive为true才能执行
     * - 状态门控：提供合约级别的功能开关
     * - 紧急停止：管理员可以通过切换isActive暂停此功能
     * 
     * 递增操作详解：
     * - 前置递增：++count比count++稍微节省gas
     * - 原子操作：整个递增过程不可中断
     * - 溢出检查：达到uint256最大值时会自动回滚
     * - 状态变更：每次调用都会永久改变合约状态
     * 
     * Gas消耗：
     * - 状态检查：约2,300 gas（whenActive修饰符）
     * - 存储读取：约800 gas（读取count当前值）
     * - 存储写入：约5,000 gas（写入新的count值）
     * - 总计：约8,100 gas
     * 
     * 使用场景：
     * - 操作统计：记录合约被调用的总次数
     * - 活动监测：追踪合约的使用频率
     * - 业务计数：统计特定业务操作的发生次数
     * - 性能测试：测试合约的响应能力
     */
    function incrementCount() public whenActive {
        count++;  
        // 计数器递增详解：
        // - 算术操作：执行加1运算，从当前值递增到下一个值
        // - 溢出安全：Solidity 0.8+内置SafeMath，自动检查溢出
        // - 存储更新：将新值写入区块链存储，永久保存
        // - 状态同步：所有节点都会同步更新这个值
        // - 事务原子性：要么成功递增，要么完全回滚
    }
    // 执行结果：
    // - count值增加1
    // - 区块链状态已更新
    // - 所有网络节点保持同步
    // - 操作记录永久保存在区块链上
    
    /**
     * @dev 为指定用户添加余额（仅限合约所有者）
     * @param _user 用户地址
     * @param _amount 要添加的金额（以wei为单位）
     * 
     * 功能概述：
     * - 余额管理：增加指定用户的虚拟余额
     * - 用户注册：新用户自动添加到系统中
     * - 权限控制：只有合约所有者可以执行此操作
     * - 事件记录：记录用户添加和余额变更
     * 
     * 执行逻辑：
     * 1. 检查调用者权限（onlyOwner修饰符）
     * 2. 增加用户余额（mapping操作）
     * 3. 检查用户是否已存在于系统
     * 4. 新用户：添加到用户列表并设置授权
     * 5. 触发UserAdded事件记录操作
     * 
     * 数据结构操作：
     * - balances mapping：O(1)时间复杂度的余额更新
     * - authorized mapping：O(1)时间复杂度的权限设置
     * - users array：O(1)添加操作，但会增加数组长度
     * 
     * Gas消耗分析：
     * - 权限检查：约2,300 gas
     * - 余额更新：约5,000-20,000 gas（首次vs后续）
     * - 授权检查：约800 gas
     * - 新用户处理：
     *   * 数组添加：约20,000-40,000 gas
     *   * 授权设置：约20,000 gas
     *   * 事件记录：约1,500 gas
     * - 总计：8,000-85,000 gas（取决于是否为新用户）
     */
    function addBalance(address _user, uint256 _amount) public onlyOwner {
        balances[_user] += _amount;  
        // 余额累加详解：
        // - Mapping操作：通过用户地址直接访问其余额
        // - 复合赋值：使用+=操作符，等价于balances[_user] = balances[_user] + _amount
        // - 默认值处理：新用户的余额从0开始累加
        // - 溢出保护：Solidity 0.8+自动检查加法溢出
        // - 原子操作：要么完全成功，要么完全回滚
        
        // 如果是新用户，添加到用户数组并设置授权
        if (!authorized[_user]) {
            // 新用户检查详解：
            // - 授权状态：通过authorized mapping检查用户是否已注册
            // - 逻辑取反：!操作符取反，false表示未授权（新用户）
            // - 防重复：避免将同一用户多次添加到数组
            // - 状态门控：基于授权状态决定是否执行注册逻辑
            
            users.push(_user);                    
            // 用户列表管理详解：
            // - 数组扩容：动态添加新用户到users数组末尾
            // - 索引分配：新用户获得数组中的唯一索引位置
            // - 遍历支持：支持后续的用户列表遍历操作
            // - 内存增长：数组长度增加，影响遍历的gas成本
            // - 永久记录：用户一旦添加，在数组中永久存在
            
            authorized[_user] = true;             
            // 授权状态设置详解：
            // - 权限标记：将用户标记为已授权状态
            // - 快速查询：后续可以O(1)时间复杂度查询用户状态
            // - 状态同步：与users数组保持数据一致性
            // - 访问控制：为基于授权的功能提供基础
            
            emit UserAdded(_user, block.timestamp);  
            // 事件记录详解：
            // - 用户追踪：记录新用户的添加操作
            // - 时间戳：block.timestamp提供区块生成时间
            // - 外部通知：前端可以监听此事件更新用户界面
            // - 审计日志：提供完整的用户注册历史
            // - indexed参数：_user参数支持高效的事件过滤
        }
    }
    // 复合操作完成后的系统状态：
    // - 用户余额已更新（无论新旧用户）
    // - 新用户已完成注册流程
    // - 所有相关数据结构保持一致性
    // - 操作历史已记录到区块链日志
    
    /**
     * @dev 获取指定用户的余额
     * @param _user 用户地址
     * @return 用户的当前余额（以wei为单位）
     * 
     * View函数特性：
     * - 只读操作：不修改任何合约状态，纯查询功能
     * - 免费调用：本地调用时不产生gas费用
     * - 实时数据：返回当前最新的用户余额
     * - 无副作用：不会产生交易或改变区块链状态
     * 
     * 查询机制：
     * - Mapping查询：通过用户地址直接查询余额
     * - O(1)复杂度：查询时间复杂度恒定，不受用户数量影响
     * - 默认值处理：未注册用户自动返回0余额
     * - 类型安全：返回值类型为uint256，确保数值精度
     * 
     * 调用方式：
     * - 外部查询：web3.js通过call方法免费查询
     * - 合约调用：其他合约可以直接调用获取余额
     * - 批量查询：可以在循环中查询多个用户余额
     * 
     * 应用场景：
     * - 余额显示：在前端界面显示用户余额
     * - 权限验证：验证用户是否有足够余额执行操作
     * - 统计分析：计算总余额、平均余额等统计数据
     * - 审计检查：验证余额数据的准确性和一致性
     * 
     * 返回值说明：
     * - 单位：wei（以太坊最小单位，1 ETH = 10^18 wei）
     * - 范围：0到2^256-1
     * - 精度：支持极高精度的数值计算
     * - 格式：无符号整数，不会返回负值
     */
    function getBalance(address _user) public view returns (uint256) {
        return balances[_user];
    }
    // Mapping查询优势：
    // - 查询速度：O(1)时间复杂度，无论数据规模多大
    // - 内存效率：不需要遍历，直接命中目标数据
    // - 并发安全：多个查询可以并发执行
    // - 数据准确性：直接从区块链状态读取，确保数据真实性
    
    /**
     * @dev 添加数字到动态数组
     * @param _number 要添加的数字
     * 
     * 功能详解：
     * - 数组扩容：向numbers动态数组末尾添加新元素
     * - 公开访问：任何人都可以调用此函数
     * - 状态修改：永久改变合约中的数组状态
     * - 顺序保持：元素按添加顺序排列
     * 
     * 动态数组特性：
     * - 自动扩容：数组长度自动增加，无需预分配空间
     * - 末尾添加：push操作将元素添加到数组最后位置
     * - 索引分配：新元素获得等于(length-1)的索引
     * - 长度更新：数组的length属性自动更新
     * 
     * 存储机制：
     * - 长度存储：数组长度存储在主存储槽
     * - 元素存储：数组元素存储在keccak256(slot)开始的连续槽中
     * - 槽位计算：第n个元素存储在keccak256(slot) + n位置
     * - 连续布局：相邻元素在存储中连续排列
     * 
     * Gas消耗分析：
     * - 基础成本：约20,000 gas（首次写入新槽）
     * - 长度更新：约5,000 gas（修改length值）
     * - 元素写入：约20,000 gas（写入新元素）
     * - 总计：约45,000 gas（可能因存储状态而变化）
     * - 扩容影响：数组越长，某些操作的gas成本可能略有增加
     * 
     * 使用注意：
     * - 无限增长：理论上可以无限添加，但受gas限制
     * - 遍历成本：数组越大，遍历操作越昂贵
     * - 存储成本：每个元素都需要支付存储费用
     * - 删除困难：删除中间元素比较复杂和昂贵
     */
    function addNumber(uint256 _number) public {
        numbers.push(_number);  
        // Push操作详解：
        // - 数组扩容：自动增加数组长度
        // - 元素添加：将新数字添加到数组末尾
        // - 存储分配：为新元素分配存储空间
        // - 索引管理：元素获得唯一的数组索引
        // - 原子操作：要么完全成功，要么完全回滚
    }
    // 执行结果：
    // - 数组长度增加1
    // - 新元素添加到末尾位置
    // - 所有现有元素位置保持不变
    // - 数组索引从0到(length-1)连续有效
    
    /**
     * @dev 获取数字数组的长度
     * @return 数组中元素的数量
     * 
     * View函数特性：
     * - 只读操作：仅查询数组长度，不修改任何状态
     * - 免费调用：本地调用时不消耗gas费用
     * - 实时数据：返回数组的当前长度
     * - 高效查询：直接读取length属性，O(1)时间复杂度
     * 
     * 数组长度特性：
     * - 动态更新：每次push或pop操作后自动更新
     * - 存储位置：length值存储在数组的主存储槽中
     * - 零基索引：有效索引范围是0到(length-1)
     * - 边界检查：访问length以上的索引会导致异常
     * 
     * 应用场景：
     * - 遍历控制：在循环中使用length作为边界条件
     * - 容量检查：验证数组是否为空或已达到某个大小
     * - 统计分析：统计数据集的大小
     * - 前端显示：在用户界面显示列表项目数量
     * 
     * 返回值说明：
     * - 类型：uint256无符号整数
     * - 范围：0到理论最大值（受gas限制）
     * - 含义：数组中实际存储的元素数量
     * - 实时性：反映调用时刻的真实数组大小
     */
    function getNumbersLength() public view returns (uint256) {
        return numbers.length;
    }
    // 数组长度查询优势：
    // - 查询速度：O(1)时间复杂度，瞬间返回结果
    // - 内存效率：直接读取存储槽，无需计算或遍历
    // - 数据准确性：与数组实际状态完全同步
    // - 并发安全：多个查询可以同时执行
    
    /**
     * @dev 切换合约的激活状态（仅限合约所有者）
     * 
     * 功能概述：
     * - 状态切换：在激活(true)和非激活(false)之间切换
     * - 权限控制：只有合约所有者可以执行此操作
     * - 系统控制：提供合约级别的功能开关机制
     * - 安全机制：紧急情况下可以快速暂停合约功能
     * 
     * 逻辑运算详解：
     * - 逻辑非操作：!isActive将当前状态取反
     * - 原子操作：状态切换是原子性的，不会出现中间状态
     * - 即时生效：状态变更立即影响带有whenActive修饰符的函数
     * - 可逆操作：可以随时在激活和非激活间切换
     * 
     * 业务应用：
     * - 维护模式：升级或维护期间暂停用户操作
     * - 紧急停止：发现安全问题时快速禁用所有功能
     * - 渐进启动：合约部署后分阶段开放功能
     * - 访问控制：基于业务需求动态控制功能可用性
     * 
     * 影响范围：
     * - whenActive修饰符：所有使用此修饰符的函数受影响
     * - 用户操作：可能导致某些用户操作暂时不可用
     * - 系统功能：核心业务逻辑的开关控制
     * - 前端交互：前端应该检查状态并相应更新界面
     * 
     * Gas消耗：
     * - 权限检查：约2,300 gas（onlyOwner修饰符）
     * - 状态读取：约800 gas（读取当前isActive值）
     * - 逻辑运算：约3 gas（执行!操作）
     * - 状态写入：约5,000 gas（写入新的isActive值）
     * - 总计：约8,103 gas
     */
    function toggleActive() public onlyOwner {
        isActive = !isActive;  
        // 状态切换详解：
        // - 逻辑取反：true变为false，false变为true
        // - 即时生效：状态变更立即生效，影响后续函数调用
        // - 持久化：新状态永久保存在区块链上
        // - 同步更新：所有网络节点同步更新状态
        // - 可见性：外部可以查询新的状态值
    }
    // 状态切换的系统影响：
    // - 功能可用性：直接影响带whenActive修饰符的函数
    // - 用户体验：可能需要通知用户系统状态变更
    // - 业务连续性：提供业务中断和恢复的控制能力
    // - 安全保障：为系统安全提供快速响应机制
    
    /**
     * @dev 更改合约的状态（仅限合约所有者）
     * @param _newStatus 新的状态值
     * 
     * 功能概述：
     * - 状态管理：更新合约的业务状态枚举
     * - 权限控制：仅合约所有者可以执行状态变更
     * - 枚举操作：使用类型安全的枚举值赋值
     * - 业务流程：支持合约状态机的转换
     * 
     * 枚举状态详解：
     * - Pending(0)：等待状态，通常表示初始或待处理状态
     * - Active(1)：活跃状态，表示正常运营状态
     * - Inactive(2)：非活跃状态，表示暂停或停用状态
     * 
     * 状态转换场景：
     * - 业务流程：根据业务需求在不同状态间转换
     * - 生命周期：反映合约或业务的生命周期阶段
     * - 工作流控制：支持复杂的工作流程管理
     * - 审批流程：可以表示审批、执行、完成等状态
     * 
     * 类型安全特性：
     * - 编译时检查：只能传入有效的Status枚举值
     * - 运行时安全：防止传入无效的状态值
     * - 自动验证：Solidity编译器自动验证参数类型
     * - 错误防护：无效输入会在编译时被拒绝
     * 
     * 应用场景：
     * - 合约升级：在升级过程中设置不同状态
     * - 业务管理：根据业务需求调整合约状态
     * - 工作流程：实现复杂的业务工作流
     * - 状态监控：便于外部系统监控合约状态
     * 
     * Gas消耗：
     * - 权限检查：约2,300 gas（onlyOwner修饰符）
     * - 枚举赋值：约5,000-20,000 gas（取决于是否首次写入）
     * - 总计：约7,300-22,300 gas
     */
    function changeStatus(Status _newStatus) public onlyOwner {
        currentStatus = _newStatus;
    }
    // 枚举操作优势：
    // - 类型安全：编译时确保只能使用有效的枚举值
    // - 代码清晰：使用具名常量而不是魔法数字
    // - 维护性强：添加新状态时编译器会提示更新相关代码
    // - 存储高效：枚举作为uint8存储，节省存储空间
    
    /**
     * @dev 创建Person结构体实例（纯函数，不依赖状态）
     * @param _name 姓名字符串
     * @param _age 年龄（年）
     * @param _wallet 钱包地址
     * @param _level 等级（0-255）
     * @return 创建的Person结构体实例
     * 
     * Pure函数特性：
     * - 无状态依赖：不读取任何合约状态变量
     * - 无副作用：不修改任何状态，不产生事件
     * - 确定性：相同输入总是产生相同输出
     * - 免费调用：本地调用时不消耗gas费用
     * - 计算函数：纯粹的数据处理和计算
     * 
     * 结构体构造详解：
     * - 字段初始化：使用具名语法初始化所有字段
     * - 类型安全：编译器确保所有必需字段都被设置
     * - 内存分配：在memory中创建临时结构体实例
     * - 自动注册：将isRegistered字段自动设为true
     * - 完整性：确保返回的结构体包含所有必需信息
     * 
     * 参数验证（建议在实际使用中添加）：
     * - 姓名验证：检查字符串长度和格式
     * - 年龄验证：确保年龄在合理范围内
     * - 地址验证：确保钱包地址不是零地址
     * - 等级验证：确保等级在有效范围内
     * 
     * 使用场景：
     * - 数据构造：为其他函数提供结构体构造服务
     * - 批量创建：在循环中创建多个Person实例
     * - 数据转换：将外部数据转换为内部结构体格式
     * - 工厂模式：作为Person对象的工厂函数
     * 
     * Gas消耗：
     * - 本地调用：0 gas（pure函数本地执行免费）
     * - 交易调用：约5,000-15,000 gas（取决于参数复杂度）
     * - 内存分配：按字符串长度和结构体大小计算
     * 
     * 返回值特性：
     * - Memory类型：返回临时的内存中结构体
     * - 完整数据：包含所有Person字段的完整实例
     * - 即用即得：可以直接使用返回的结构体
     * - 类型安全：返回值类型明确，编译时检查
     */
    function createPerson(
        string memory _name, 
        uint256 _age, 
        address _wallet, 
        uint8 _level
    ) public pure returns (Person memory) {
        return Person({
            name: _name,
            age: _age,
            isRegistered: true,
            wallet: _wallet,
            level: _level
        });
    }
    // 结构体字面量语法详解：
    // - 具名初始化：使用字段名显式赋值，提高代码可读性
    // - 字段完整性：编译器确保所有字段都被正确初始化
    // - 类型匹配：编译器验证每个字段的类型匹配
    // - 默认设置：isRegistered自动设为true，表示创建即注册
    // - 内存效率：在memory中高效创建，避免不必要的storage操作
    // 
    // Pure函数的优势：
    // - 可预测性：相同输入始终产生相同输出
    // - 可测试性：易于单元测试，无需模拟复杂状态
    // - 可重用性：可以在任何地方调用，不依赖合约状态
    // - 并发安全：多个调用可以并发执行
    // - Gas优化：本地调用完全免费
    
    // ============ 基本数据结构操作函数 (Basic Data Structure Operations) ============
    // 这部分函数演示了各种基本数据类型的操作和管理方法
    // 主要用途：教学演示、数据测试、类型验证、功能展示
    
    /**
     * @dev 设置基本数据类型值的示例函数（仅限合约所有者）
     * @param _small 8位无符号整数值（0-255）
     * @param _medium 128位无符号整数值（0到2^128-1）
     * @param _signed 256位有符号整数值（支持负数）
     * 
     * 功能概述：
     * - 类型演示：展示不同整数类型的赋值操作
     * - 范围验证：编译器自动检查数值范围的合法性
     * - 权限控制：只有合约所有者可以修改这些基础数据
     * - 状态更新：永久更新合约中的基础数据类型状态变量
     * 
     * 参数详解：
     * - _small (uint8)：
     *   * 数值范围：0到255
     *   * 存储优化：可与其他小类型打包存储
     *   * 常见用途：百分比、等级、状态码
     *   * 溢出检查：超出范围会编译错误
     * 
     * - _medium (uint128)：
     *   * 数值范围：0到340,282,366,920,938,463,463,374,607,431,768,211,455
     *   * 存储优化：两个uint128可共享一个存储槽
     *   * 常见用途：大额代币数量、时间戳、哈希值
     *   * 精度平衡：在存储效率和数值范围间平衡
     * 
     * - _signed (int256)：
     *   * 数值范围：-2^255到2^255-1
     *   * 负数支持：使用二进制补码表示负数
     *   * 常见用途：温度、坐标、差值计算
     *   * 类型转换：可与uint256相互转换
     * 
     * 类型安全特性：
     * - 编译时检查：Solidity编译器验证类型匹配
     * - 自动转换：较小类型会自动提升进行运算
     * - 溢出保护：Solidity 0.8+内置溢出检查
     * - 精度保证：不会丢失数值精度
     * 
     * Gas消耗分析：
     * - 权限检查：约2,300 gas
     * - 三次赋值：约15,000-60,000 gas（取决于是否首次写入）
     * - 类型转换：几乎无额外成本
     * - 总计：约17,300-62,300 gas
     * 
     * 使用场景：
     * - 数据初始化：为不同类型的变量设置初始值
     * - 配置更新：动态调整合约的配置参数
     * - 测试验证：验证不同数据类型的行为
     * - 演示教学：展示Solidity类型系统的特性
     */
    function setBasicTypes(uint8 _small, uint128 _medium, int256 _signed) public onlyOwner {
        smallNumber = _small;        
        // 8位整数赋值详解：
        // - 范围检查：编译器确保值在0-255范围内
        // - 存储位置：可能与其他小类型变量打包在同一存储槽
        // - 类型转换：参数自动转换为uint8类型
        // - 状态更新：永久修改合约状态变量
        
        mediumNumber = _medium;      
        // 128位整数赋值详解：
        // - 范围验证：编译器检查值不超过2^128-1
        // - 存储优化：与另一个uint128可以共享32字节存储槽
        // - 精度保持：保持完整的128位精度
        // - 大数支持：支持非常大的数值运算
        
        signedNumber = _signed;      
        // 有符号整数赋值详解：
        // - 负数支持：使用二进制补码存储负数
        // - 全范围：支持从-2^255到2^255-1的完整范围
        // - 符号位：最高位作为符号位（0正1负）
        // - 运算支持：支持包括负数在内的所有算术运算
    }
    // 函数执行结果：
    // - 三个不同类型的状态变量都已更新
    // - 所有类型安全检查都已通过
    // - 新值已永久存储在区块链上
    // - 后续查询将返回新设置的值
    
    /**
     * @dev 操作字节类型的示例函数（仅限合约所有者）
     * @param _fixedBytes 32字节固定长度数据
     * @param _dynamicData 动态字节数据
     * 
     * 功能概述：
     * - 字节操作：演示固定和动态字节类型的使用
     * - 数据存储：更新合约中的字节类型状态变量
     * - 类型对比：展示bytes32和bytes的不同特性
     * - 权限控制：只有合约所有者可以修改字节数据
     * 
     * 参数类型分析：
     * - _fixedBytes (bytes32)：
     *   * 固定长度：总是占用32字节
     *   * 存储效率：占用一个完整存储槽
     *   * 数据格式：可以是哈希值、密钥、固定标识符
     *   * 右填充：短于32字节的数据会右侧填充零
     *   * 比较操作：支持直接相等比较
     * 
     * - _dynamicData (bytes memory)：
     *   * 动态长度：长度根据实际数据确定
     *   * 存储复杂：长度和数据分离存储
     *   * 灵活性：可以存储任意长度的二进制数据
     *   * 操作丰富：支持push、pop、索引访问等操作
     *   * 编码兼容：与string类型可以相互转换
     * 
     * 字节操作特性：
     * - 二进制数据：直接处理原始字节数据
     * - 编码无关：不关心字符编码，按字节处理
     * - 索引访问：支持按索引读写单个字节
     * - 长度获取：可以获取字节数组的实际长度
     * - 连接操作：可以使用abi.encodePacked连接
     * 
     * Gas消耗分析：
     * - 权限检查：约2,300 gas
     * - 固定字节赋值：约5,000-20,000 gas
     * - 动态字节赋值：5,000-50,000+ gas（取决于数据长度）
     * - 总计：约12,300-72,300+ gas
     * 
     * 应用场景：
     * - 哈希存储：存储文件哈希、交易哈希等
     * - 密钥管理：存储加密密钥或签名数据
     * - 二进制数据：存储图片、文档等二进制内容
     * - 编码数据：存储ABI编码后的复杂数据结构
     */
    function setBytesData(bytes32 _fixedBytes, bytes memory _dynamicData) public onlyOwner {
        fixedBytes = _fixedBytes;    
        // 固定字节赋值详解：
        // - 长度固定：总是32字节，不可变更
        // - 存储直接：直接存储到32字节存储槽中
        // - 数据格式：通常用于哈希值、密钥、唯一标识符
        // - 填充规则：数据不足32字节时右侧自动填充零
        // - 比较高效：支持直接的相等性比较操作
        
        dynamicBytes = _dynamicData; 
        // 动态字节赋值详解：
        // - 长度可变：根据实际数据长度动态调整
        // - 存储复杂：长度存储在主槽，数据存储在计算位置
        // - 内存优化：使用memory参数减少临时拷贝
        // - 灵活操作：支持索引访问、长度查询、元素修改
        // - 编码兼容：可以与string类型相互转换
        
        singleByte = _fixedBytes[0]; 
        // 字节提取详解：
        // - 索引访问：从32字节数据中提取第一个字节
        // - 类型转换：bytes32的第一个字节转换为bytes1
        // - 位操作：展示字节级别的数据操作能力
        // - 数据解析：从复合数据中提取特定部分
        // - 应用示例：提取标志位、版本号、类型标识等
    }
    // 函数完成后的状态：
    // - 固定字节数据已更新
    // - 动态字节数据已存储
    // - 单字节已从固定字节中提取
    // - 所有字节类型变量状态一致
    
    /**
     * @dev 操作固定数组的示例函数
     * @param _index 数组索引
     * @param _value 要设置的值
     */
    function setFixedArrayValue(uint256 _index, uint256 _value) public {
        require(_index < 5, "Index out of bounds"); // 边界检查
        fixedArray[_index] = _value; // 固定数组元素赋值
    }
    // 固定数组特性：编译时长度检查、运行时边界检查、连续存储
    
    /**
     * @dev 添加二维数组数据
     * @param _row 要添加的一维数组
     */
    function addMatrixRow(uint256[] memory _row) public {
        matrix.push(_row);  // 向二维数组添加一行
    }
    // 多维数组特性：嵌套动态分配、内存布局复杂、gas消耗较高
    
    /**
     * @dev 设置嵌套映射值
     * @param _user 用户地址
     * @param _id ID值
     * @param _permission 权限状态
     */
    function setNestedMapping(address _user, uint256 _id, bool _permission) public onlyOwner {
        nestedMapping[_user][_id] = _permission; // 嵌套映射赋值
    }
    // 嵌套映射特性：双重键访问、支持复杂数据关系、gas消耗固定
    
    /**
     * @dev 创建并存储Person结构体
     * @param _user 用户地址
     * @param _name 姓名
     * @param _age 年龄
     * @param _wallet 钱包地址
     * @param _level 等级
     */
    function createPersonStruct(
        address _user,
        string memory _name,
        uint256 _age,
        address _wallet,
        uint8 _level
    ) public onlyOwner {
        personData[_user] = Person({
            name: _name,
            age: _age,
            isRegistered: true,
            wallet: _wallet,
            level: _level
        });
    }
    // 结构体特性：字段组合、类型安全、存储优化、便于管理
    
    /**
     * @dev 设置枚举值示例
     * @param _priority 任务优先级
     * @param _role 用户角色
     */
    function setEnumValues(Priority _priority, UserRole _role) public onlyOwner {
        taskPriority = _priority;  // 枚举赋值 - 类型安全
        userRole = _role;          // 用户角色设置
    }
    // 枚举特性：类型安全、有限选项、可读性强、避免魔法数字
    
    // ============ 运算操作示例函数 ============
    // 演示 Solidity 中各种运算符的使用
    
    /**
     * @dev 算术运算示例
     * @param a 第一个操作数
     * @param b 第二个操作数
     * @return sum 加法结果
     * @return diff 减法结果
     * @return product 乘法结果
     * @return quotient 除法结果
     * @return remainder 取模结果
     */
    function arithmeticOperations(uint256 a, uint256 b) 
        public 
        pure 
        returns (
            uint256 sum,
            uint256 diff,
            uint256 product,
            uint256 quotient,
            uint256 remainder
        ) 
    {
        require(b != 0, "Division by zero");  // 防止除零错误
        
        sum = a + b;          // 加法运算 - Solidity 0.8+自动溢出检查
        diff = a > b ? a - b : 0;  // 减法运算 - 防止下溢，返回0而不是回滚
        product = a * b;      // 乘法运算 - 自动溢出保护
        quotient = a / b;     // 除法运算 - 整数除法，向下取整
        remainder = a % b;    // 取模运算 - 求余数
    }
    // 算术特性：自动溢出检查、整数运算、向下取整除法
    
    /**
     * @dev 比较运算示例
     * @param a 第一个操作数
     * @param b 第二个操作数
     * @return isEqual a是否等于b
     * @return isNotEqual a是否不等于b
     * @return isGreater a是否大于b
     * @return isLess a是否小于b
     * @return isGreaterOrEqual a是否大于等于b
     * @return isLessOrEqual a是否小于等于b
     */
    function comparisonOperations(uint256 a, uint256 b) 
        public 
        pure 
        returns (
            bool isEqual,
            bool isNotEqual,
            bool isGreater,
            bool isLess,
            bool isGreaterOrEqual,
            bool isLessOrEqual
        ) 
    {
        isEqual = (a == b);           // 等于比较
        isNotEqual = (a != b);        // 不等于比较
        isGreater = (a > b);          // 大于比较
        isLess = (a < b);             // 小于比较
        isGreaterOrEqual = (a >= b);  // 大于等于比较
        isLessOrEqual = (a <= b);     // 小于等于比较
    }
    // 比较特性：返回布尔值、支持所有数值类型、地址类型也可比较
    
    /**
     * @dev 逻辑运算示例
     * @param a 第一个布尔值
     * @param b 第二个布尔值
     * @return andResult 逻辑与结果
     * @return orResult 逻辑或结果
     * @return notA 逻辑非a的结果
     * @return notB 逻辑非b的结果
     */
    function logicalOperations(bool a, bool b) 
        public 
        pure 
        returns (
            bool andResult,
            bool orResult,
            bool notA,
            bool notB
        ) 
    {
        andResult = a && b;    // 逻辑与 - 两个都为true时才为true
        orResult = a || b;     // 逻辑或 - 至少一个为true时为true
        notA = !a;             // 逻辑非 - 取反操作
        notB = !b;             // 逻辑非 - 取反操作
    }
    // 逻辑特性：短路求值、&&和||支持短路、!总是求值
    
    /**
     * @dev 位运算示例
     * @param a 第一个操作数
     * @param b 第二个操作数
     * @return andResult 按位与结果
     * @return orResult 按位或结果
     * @return xorResult 按位异或结果
     * @return notA 按位取反a的结果
     * @return leftShift a左移1位的结果
     * @return rightShift a右移1位的结果
     */
    function bitwiseOperations(uint256 a, uint256 b) 
        public 
        pure 
        returns (
            uint256 andResult,
            uint256 orResult,
            uint256 xorResult,
            uint256 notA,
            uint256 leftShift,
            uint256 rightShift
        ) 
    {
        andResult = a & b;     // 按位与 - 对应位都为1时结果为1
        orResult = a | b;      // 按位或 - 对应位至少一个为1时结果为1
        xorResult = a ^ b;     // 按位异或 - 对应位不同时结果为1
        notA = ~a;             // 按位取反 - 所有位取反
        leftShift = a << 1;    // 左移 - 相当于乘以2
        rightShift = a >> 1;   // 右移 - 相当于除以2（向下取整）
    }
    // 位运算特性：直接操作二进制位、高效计算、移位运算等价于乘除2的幂
    
    /**
     * @dev 赋值运算示例（修改状态变量）
     * @param value 新的计数值
     */
    function assignmentOperations(uint256 value) public onlyOwner {
        count = value;           // 基本赋值
        count += 10;             // 加法赋值 - 等价于 count = count + 10
        count -= 5;              // 减法赋值 - 等价于 count = count - 5
        count *= 2;              // 乘法赋值 - 等价于 count = count * 2
        count /= 3;              // 除法赋值 - 等价于 count = count / 3
        count %= 100;            // 取模赋值 - 等价于 count = count % 100
        
        // 位运算赋值
        smallNumber |= 0x0F;     // 按位或赋值
        smallNumber &= 0xF0;     // 按位与赋值
        smallNumber ^= 0xFF;     // 按位异或赋值
    }
    // 赋值特性：简化语法、状态修改、gas消耗、溢出保护
    
    /**
     * @dev 自增自减运算示例
     * @return preIncrement 前置自增结果
     * @return postIncrement 后置自增结果
     * @return preDecrement 前置自减结果
     * @return postDecrement 后置自减结果
     */
    function incrementDecrementOperations() public returns (
        uint256 preIncrement,
        uint256 postIncrement,
        uint256 preDecrement,
        uint256 postDecrement
    ) {
        uint256 temp = count;
        
        preIncrement = ++temp;    // 前置自增 - 先加1再返回值
        temp = count;
        postIncrement = temp++;   // 后置自增 - 先返回值再加1
        
        temp = count;
        preDecrement = --temp;    // 前置自减 - 先减1再返回值
        temp = count;
        postDecrement = temp--;   // 后置自减 - 先返回值再减1
        
        count = temp;             // 更新状态变量
    }
    // 自增自减特性：前置和后置区别、返回值不同、状态修改
    
    /**
     * @dev 条件（三元）运算符示例
     * @param condition 条件表达式
     * @param a 条件为true时的值
     * @param b 条件为false时的值
     * @return result 条件运算结果
     */
    function conditionalOperator(bool condition, uint256 a, uint256 b) 
        public 
        pure 
        returns (uint256 result) 
    {
        result = condition ? a : b;  // 三元运算符 - condition为true返回a，否则返回b
        
        // 复杂条件示例
        uint256 complexResult = (a > b) ? (a - b) : (b - a);  // 求绝对差值
        result = result > complexResult ? result : complexResult;  // 取较大值
    }
    // 条件运算符特性：简洁语法、类型必须相同、可嵌套使用
    
    /**
     * @dev 数学函数示例（使用内置函数和自定义计算）
     * @param base 底数
     * @param exponent 指数
     * @param value 输入值
     * @return power 幂运算结果
     * @return absoluteValue 绝对值
     * @return maximum 最大值
     * @return minimum 最小值
     */
    function mathFunctions(int256 base, uint256 exponent, int256 value) 
        public 
        pure 
        returns (
            int256 power,
            int256 absoluteValue,
            int256 maximum,
            int256 minimum
        ) 
    {
        // 幂运算（简单实现）
        power = 1;
        for (uint256 i = 0; i < exponent; i++) {
            power *= base;
        }
        
        // 绝对值计算
        absoluteValue = value >= 0 ? value : -value;
        
        // 最大值和最小值
        maximum = base > value ? base : value;
        minimum = base < value ? base : value;
    }
    // 数学函数特性：循环实现、条件判断、有符号数处理
    
    /**
     * @dev 字符串和字节运算示例
     * @param str1 第一个字符串
     * @param str2 第二个字符串
     * @param data1 第一个字节数据
     * @param data2 第二个字节数据
     * @return concatenated 连接后的字符串
     * @return combinedBytes 合并后的字节数据
     * @return isEqual 字符串是否相等
     * @return length1 第一个字符串长度
     */
    function stringAndBytesOperations(
        string memory str1,
        string memory str2,
        bytes memory data1,
        bytes memory data2
    ) 
        public 
        pure 
        returns (
            string memory concatenated,
            bytes memory combinedBytes,
            bool isEqual,
            uint256 length1
        ) 
    {
        // 字符串连接
        concatenated = string(abi.encodePacked(str1, str2));
        
        // 字节数据合并
        combinedBytes = abi.encodePacked(data1, data2);
        
        // 字符串比较（通过哈希值比较）
        isEqual = keccak256(abi.encodePacked(str1)) == keccak256(abi.encodePacked(str2));
        
        // 字符串长度（字节长度）
        length1 = bytes(str1).length;
    }
    // 字符串字节特性：abi.encodePacked连接、keccak256哈希、length属性
    
    // ============ 控制流程示例函数 ============
    // 演示 Solidity 中循环、迭代和条件语句的使用
    
    /**
     * @dev if-else 条件语句示例
     * @param score 分数
     * @param age 年龄
     * @return grade 等级评定
     * @return category 年龄分类
     * @return isEligible 是否符合条件
     */
    function conditionalStatements(uint256 score, uint256 age) 
        public 
        pure 
        returns (
            string memory grade,
            string memory category,
            bool isEligible
        ) 
    {
        // ========== 简单 if-else 语句 ==========
        if (score >= 90) {
            grade = "A";
        } else if (score >= 80) {
            grade = "B";
        } else if (score >= 70) {
            grade = "C";
        } else if (score >= 60) {
            grade = "D";
        } else {
            grade = "F";
        }
        
        // ========== 嵌套 if-else 语句 ==========
        if (age < 18) {
            category = "Minor";
            if (age < 13) {
                category = "Child";
            } else {
                category = "Teenager";
            }
        } else if (age < 65) {
            category = "Adult";
            if (age < 30) {
                category = "Young Adult";
            } else if (age < 50) {
                category = "Middle Age";
            } else {
                category = "Senior Adult";
            }
        } else {
            category = "Elder";
        }
        
        // ========== 复合条件判断 ==========
        if (score >= 70 && age >= 18) {
            isEligible = true;
        } else if (score >= 80 && age >= 16) {
            isEligible = true;
        } else if (score >= 90) {  // 优异成绩不限年龄
            isEligible = true;
        } else {
            isEligible = false;
        }
    }
    // 条件语句特性：逻辑分支、嵌套结构、复合条件、短路求值
    
    /**
     * @dev for 循环示例
     * @param start 起始值
     * @param end 结束值
     * @param step 步长
     * @return sum 求和结果
     * @return product 乘积结果
     * @return evenCount 偶数个数
     * @return resultArray 结果数组
     */
    function forLoopExamples(uint256 start, uint256 end, uint256 step) 
        public 
        pure 
        returns (
            uint256 sum,
            uint256 product,
            uint256 evenCount,
            uint256[] memory resultArray
        ) 
    {
        require(start <= end, "Start must be less than or equal to end");
        require(step > 0, "Step must be greater than zero");
        
        // 计算数组大小
        uint256 arraySize = (end - start) / step + 1;
        resultArray = new uint256[](arraySize);
        
        product = 1;
        uint256 index = 0;
        
        // ========== 基本 for 循环 ==========
        for (uint256 i = start; i <= end; i += step) {
            sum += i;                    // 累加求和
            product *= i;                // 累乘求积
            resultArray[index] = i;      // 存储到数组
            index++;
            
            // 条件判断
            if (i % 2 == 0) {
                evenCount++;             // 统计偶数
            }
        }
        
        // ========== 数组遍历 for 循环 ==========
        // 对结果数组进行处理
        for (uint256 j = 0; j < resultArray.length; j++) {
            if (resultArray[j] > 10) {
                resultArray[j] = resultArray[j] * 2;  // 大于10的数乘以2
            }
        }
    }
    // for循环特性：初始化、条件检查、递增操作、数组遍历
    
    /**
     * @dev while 循环示例
     * @param target 目标值
     * @param multiplier 乘数
     * @return iterations 迭代次数
     * @return finalValue 最终值
     * @return steps 每步的值
     */
    function whileLoopExamples(uint256 target, uint256 multiplier) 
        public 
        pure 
        returns (
            uint256 iterations,
            uint256 finalValue,
            uint256[] memory steps
        ) 
    {
        require(multiplier > 1, "Multiplier must be greater than 1");
        require(target > 0, "Target must be positive");
        
        finalValue = 1;
        iterations = 0;
        
        // 先计算需要多少步
        uint256 tempValue = 1;
        uint256 tempIterations = 0;
        while (tempValue < target) {
            tempValue *= multiplier;
            tempIterations++;
        }
        
        // 创建数组存储每步的值
        steps = new uint256[](tempIterations + 1);
        steps[0] = 1;
        
        // ========== while 循环实际计算 ==========
        finalValue = 1;
        while (finalValue < target) {
            iterations++;
            finalValue *= multiplier;
            steps[iterations] = finalValue;
        }
    }
    // while循环特性：条件控制、动态迭代、适合不确定次数的循环
    
    /**
     * @dev do-while 循环示例
     * @param seed 种子值
     * @param threshold 阈值
     * @return sequence 生成的序列
     * @return length 序列长度
     */
    function doWhileLoopExample(uint256 seed, uint256 threshold) 
        public 
        pure 
        returns (
            uint256[] memory sequence,
            uint256 length
        ) 
    {
        require(seed > 0, "Seed must be positive");
        require(threshold > seed, "Threshold must be greater than seed");
        
        // 预估数组大小（简单估算）
        uint256 estimatedSize = 20;
        uint256[] memory tempSequence = new uint256[](estimatedSize);
        
        uint256 current = seed;
        length = 0;
        
        // ========== do-while 循环（模拟实现） ==========
        // Solidity 没有 do-while，用 while 模拟
        bool firstRun = true;
        while (firstRun || current < threshold) {
            firstRun = false;
            
            if (length < estimatedSize) {
                tempSequence[length] = current;
            }
            length++;
            
            // 简单的序列生成规则
            if (current % 2 == 0) {
                current = current / 2;
            } else {
                current = current * 3 + 1;  // Collatz 序列
            }
            
            // 防止无限循环
            if (length > 100) {
                break;
            }
        }
        
        // 创建正确大小的数组
        sequence = new uint256[](length > estimatedSize ? estimatedSize : length);
        for (uint256 i = 0; i < sequence.length; i++) {
            sequence[i] = tempSequence[i];
        }
    }
    // do-while特性：至少执行一次、后检查条件、适合至少需要执行一次的场景
    
    /**
     * @dev 嵌套循环示例 - 矩阵操作
     * @param rows 行数
     * @param cols 列数
     * @return resultMatrix 生成的矩阵
     * @return sum 矩阵元素总和
     * @return diagonal 对角线元素
     */
    function nestedLoopExample(uint256 rows, uint256 cols) 
        public 
        pure 
        returns (
            uint256[][] memory resultMatrix,
            uint256 sum,
            uint256[] memory diagonal
        ) 
    {
        require(rows > 0 && rows <= 10, "Rows must be between 1 and 10");
        require(cols > 0 && cols <= 10, "Cols must be between 1 and 10");
        
        // 初始化矩阵
        resultMatrix = new uint256[][](rows);
        for (uint256 i = 0; i < rows; i++) {
            resultMatrix[i] = new uint256[](cols);
        }
        
        // 对角线数组大小
        uint256 diagonalSize = rows < cols ? rows : cols;
        diagonal = new uint256[](diagonalSize);
        
        // ========== 嵌套 for 循环 ==========
        for (uint256 i = 0; i < rows; i++) {
            for (uint256 j = 0; j < cols; j++) {
                // 生成矩阵元素：行索引 * 列数 + 列索引
                resultMatrix[i][j] = i * cols + j + 1;
                sum += resultMatrix[i][j];
                
                // 提取对角线元素
                if (i == j && i < diagonalSize) {
                    diagonal[i] = resultMatrix[i][j];
                }
            }
        }
    }
    // 嵌套循环特性：二维遍历、矩阵操作、条件筛选、时间复杂度O(n²)
    
    /**
     * @dev 循环控制语句示例 - break 和 continue
     * @param inputNumbers 输入数组
     * @param target 目标值
     * @return foundIndex 找到目标值的索引
     * @return processedNumbers 处理后的数组
     * @return skipCount 跳过的元素数量
     */
    function loopControlExample(uint256[] memory inputNumbers, uint256 target) 
        public 
        pure 
        returns (
            int256 foundIndex,
            uint256[] memory processedNumbers,
            uint256 skipCount
        ) 
    {
        foundIndex = -1;  // 未找到时返回-1
        processedNumbers = new uint256[](inputNumbers.length);
        skipCount = 0;
        uint256 processedIndex = 0;
        
        // ========== 使用 break 和 continue 的循环 ==========
        for (uint256 i = 0; i < inputNumbers.length; i++) {
            // continue 示例：跳过偶数
            if (inputNumbers[i] % 2 == 0) {
                skipCount++;
                continue;  // 跳过本次循环的剩余部分
            }
            
            // 处理奇数
            processedNumbers[processedIndex] = inputNumbers[i] * 2;
            processedIndex++;
            
            // break 示例：找到目标值后停止
            if (inputNumbers[i] == target) {
                foundIndex = int256(i);
                break;  // 退出循环
            }
        }
        
        // 调整处理后数组的大小
        uint256[] memory finalArray = new uint256[](processedIndex);
        for (uint256 j = 0; j < processedIndex; j++) {
            finalArray[j] = processedNumbers[j];
        }
        processedNumbers = finalArray;
    }
    // 循环控制特性：break退出循环、continue跳过迭代、条件控制流程
    
    /**
     * @dev 数组迭代和处理示例
     * @param inputArray 输入数组
     * @return sum 数组元素总和
     * @return average 平均值
     * @return max 最大值
     * @return min 最小值
     * @return sortedArray 排序后的数组（简单冒泡排序）
     */
    function arrayIterationExample(uint256[] memory inputArray) 
        public 
        pure 
        returns (
            uint256 sum,
            uint256 average,
            uint256 max,
            uint256 min,
            uint256[] memory sortedArray
        ) 
    {
        require(inputArray.length > 0, "Array cannot be empty");
        
        sortedArray = new uint256[](inputArray.length);
        
        // 复制数组
        for (uint256 i = 0; i < inputArray.length; i++) {
            sortedArray[i] = inputArray[i];
        }
        
        // ========== 数组统计迭代 ==========
        sum = inputArray[0];
        max = inputArray[0];
        min = inputArray[0];
        
        for (uint256 i = 1; i < inputArray.length; i++) {
            sum += inputArray[i];
            
            if (inputArray[i] > max) {
                max = inputArray[i];
            }
            
            if (inputArray[i] < min) {
                min = inputArray[i];
            }
        }
        
        average = sum / inputArray.length;
        
        // ========== 冒泡排序（嵌套循环） ==========
        for (uint256 i = 0; i < sortedArray.length - 1; i++) {
            for (uint256 j = 0; j < sortedArray.length - i - 1; j++) {
                if (sortedArray[j] > sortedArray[j + 1]) {
                    // 交换元素
                    uint256 temp = sortedArray[j];
                    sortedArray[j] = sortedArray[j + 1];
                    sortedArray[j + 1] = temp;
                }
            }
        }
    }
    // 数组迭代特性：遍历处理、统计计算、排序算法、元素交换
    
    /**
     * @dev 复杂条件和循环组合示例 - 质数检测
     * @param start 起始数
     * @param end 结束数
     * @return primes 质数数组
     * @return primeCount 质数个数
     */
    function complexIterationExample(uint256 start, uint256 end) 
        public 
        pure 
        returns (
            uint256[] memory primes,
            uint256 primeCount
        ) 
    {
        require(start >= 2, "Start must be at least 2");
        require(end >= start, "End must be greater than or equal to start");
        require(end - start <= 100, "Range too large, maximum 100 numbers");
        
        // 临时数组存储质数
        uint256[] memory tempPrimes = new uint256[](end - start + 1);
        primeCount = 0;
        
        // ========== 质数检测算法 ==========
        for (uint256 num = start; num <= end; num++) {
            bool isPrime = true;
            
            // 特殊情况处理
            if (num < 2) {
                isPrime = false;
            } else if (num == 2) {
                isPrime = true;
            } else if (num % 2 == 0) {
                isPrime = false;
            } else {
                // 检查奇数因子到平方根
                for (uint256 i = 3; i * i <= num; i += 2) {
                    if (num % i == 0) {
                        isPrime = false;
                        break;  // 找到因子，不是质数
                    }
                }
            }
            
            // 如果是质数，添加到结果数组
            if (isPrime) {
                tempPrimes[primeCount] = num;
                primeCount++;
            }
        }
        
        // 创建正确大小的结果数组
        primes = new uint256[](primeCount);
        for (uint256 j = 0; j < primeCount; j++) {
            primes[j] = tempPrimes[j];
        }
    }
    // 复杂迭代特性：算法实现、优化技巧、break控制、数学计算
    
    // ============ 支付相关函数 ============
    // 特性：以太币处理、payable机制、余额管理、转账操作
    
    /**
     * @dev 存款函数，接收以太币并记录到用户余额
     * payable关键字允许函数接收以太币
     * 特性：接收以太币、余额记录、msg.value获取、自动转换wei
     */
    function deposit() public payable {
        balances[msg.sender] += msg.value;  // msg.value是发送的以太币数量（以wei为单位）
    }
    // payable特性：函数可接收ETH、msg.value获取发送金额、合约余额自动增加
    
    /**
     * @dev 提取以太币
     * @param _amount 要提取的金额（以wei为单位）
     * 特性：余额检查、安全转账、双重验证、防重入攻击
     */
    function withdraw(uint256 _amount) public {
        // 检查用户余额是否足够
        require(balances[msg.sender] >= _amount, "Insufficient balance");
        // 检查合约余额是否足够
        require(address(this).balance >= _amount, "Contract has insufficient funds");
        
        balances[msg.sender] -= _amount;           // 减少用户余额 - 先修改状态
        
        // 现代化的安全转账方式（推荐）
        (bool success, ) = payable(msg.sender).call{value: _amount}("");
        require(success, "Transfer failed");
        
        // 弃用方式（保留作为教学对比）：
        // payable(msg.sender).transfer(_amount);  // 有gas限制，可能失败
    }
    // 安全模式：检查-效果-交互模式，先检查条件，再修改状态，最后外部调用
    
    /**
     * @dev 获取合约的以太币余额
     * @return 合约持有的以太币数量（以wei为单位）
     * 特性：view函数、地址余额查询、实时余额、免费调用
     */
    function getContractBalance() public view returns (uint256) {
        return address(this).balance;  // address(this)表示当前合约地址
    }
    // 地址余额特性：实时更新、wei为单位、包含所有接收的ETH
    
    // ============ 特殊函数 ============
    // 特性：自动触发、无函数名、特定场景、gas限制
    
    /**
     * @dev Fallback函数 - 当合约收到以太币但没有调用特定函数时触发
     * receive函数专门处理纯以太币转账（没有数据的交易）
     * 特性：自动执行、无参数、payable、gas限制2300
     */
    receive() external payable {
        deposit();  // 自动调用存款函数
    }
    // receive特性：external可见性、必须payable、无calldata时触发、gas限制严格
    
    /**
     * @dev 现代化的合约停用机制 - 替代已弃用的 selfdestruct
     * 
     * ⚠️  重要警告：selfdestruct 已被弃用！
     * 从 Cancun 硬分叉开始，selfdestruct 行为已改变：
     * - 不再删除合约代码和数据
     * - 只转移以太币到受益人
     * - 除非在创建合约的同一交易中执行
     * - 强烈不建议在新合约中使用
     * - 未来 EVM 版本可能进一步限制此功能
     * 
     * 现代化替代方案：
     * - 使用访问控制限制关键功能
     * - 实现合约暂停机制
     * - 使用代理模式进行升级
     * 
     * 特性：合约控制、余额管理、可逆操作、状态保持
     */
    
    // 合约状态控制
    bool public isContractDisabled = false;
    
    // 事件定义
    event ContractDisabled(address indexed owner, uint256 timestamp);
    event EmergencyWithdraw(address indexed recipient, uint256 amount);
    
    /**
     * @dev 禁用合约功能 - 现代化的停用方案
     */
    function disableContract() public onlyOwner {
        require(!isContractDisabled, "Contract already disabled");
        isContractDisabled = true;
        emit ContractDisabled(owner, block.timestamp);
    }
    
    /**
     * @dev 紧急提取资金 - 替代 selfdestruct 的资金转移功能
     */
    function emergencyWithdraw() public onlyOwner {
        require(isContractDisabled, "Contract must be disabled first");
        uint256 balance = address(this).balance;
        require(balance > 0, "No funds to withdraw");
        
        (bool success, ) = payable(owner).call{value: balance}("");
        require(success, "Transfer failed");
        
        emit EmergencyWithdraw(owner, balance);
    }
    
    /**
     * @dev 重新启用合约
     */
    function enableContract() public onlyOwner {
        require(isContractDisabled, "Contract not disabled");
        isContractDisabled = false;
    }
    
    /**
     * @dev 检查合约是否可用的修饰符
     */
    modifier whenNotDisabled() {
        require(!isContractDisabled, "Contract is disabled");
        _;
    }
    
    /**
     * @dev 已弃用的销毁函数 - 仅保留作为教学示例
     * ⚠️ 不建议使用：请使用 disableContract() 和 emergencyWithdraw()
     */
    function destroy() public view onlyOwner {
        // 不再执行实际的 selfdestruct 操作
        revert("selfdestruct is deprecated. Use disableContract() and emergencyWithdraw() instead");
        
        // 原始弃用代码（已注释）：
        // selfdestruct(payable(owner));  // 销毁合约并转移余额
    }
    // selfdestruct特性：删除合约代码、转移所有余额、释放存储、操作不可逆
    // 重要：新部署的合约强烈不建议使用，未来EVM可能进一步限制此操作
    
    // ============ 高级特性示例 (Advanced Features) ============
    // 这部分展示 Solidity 的高级特性和现代最佳实践
    
    /**
     * @dev 错误处理示例 - 展示不同的错误处理方法
     * @param value 输入值
     * @param useRevert 是否使用 revert
     * @return result 处理结果
     * 
     * 错误处理方式对比：
     * - require：输入验证和前置条件检查，返回剩余gas
     * - assert：内部错误和不应该发生的情况，消耗所有gas
     * - revert：自定义错误处理逻辑，返回剩余gas
     * - try/catch：外部调用错误处理（合约间调用）
     */
    function errorHandlingExamples(uint256 value, bool useRevert) 
        public 
        pure 
        returns (uint256 result) 
    {
        // ========== require 示例 ==========
        // 用于输入验证和前置条件检查
        require(value > 0, "Value must be positive");
        require(value <= 1000, "Value too large");
        
        // ========== assert 示例 ==========
        // 用于检查不应该发生的情况（内部错误）
        uint256 doubled = value * 2;
        assert(doubled >= value);  // 检查乘法没有溢出（在Solidity 0.8+中自动检查）
        
        // ========== revert 示例 ==========
        if (useRevert && value == 666) {
            revert("Forbidden value detected");  // 自定义错误处理
        }
        
        // ========== 自定义错误（Solidity 0.8.4+）==========
        if (value == 999) {
            revert CustomError(value, "Special case error");
        }
        
        result = value * value;
        
        // 后置条件检查
        assert(result >= value);  // 确保结果合理
    }
    
    // 自定义错误定义（gas效率更高）
    error CustomError(uint256 value, string message);
    
    /**
     * @dev 内联汇编示例 - 展示低级操作
     * @param a 第一个操作数
     * @param b 第二个操作数
     * @return sum 加法结果
     * @return product 乘法结果
     * 
     * 内联汇编特性：
     * - 直接操作EVM字节码
     * - 更高的gas效率
     * - 更多底层控制
     * - 需要深入理解EVM
     * 
     * 警告：内联汇编破坏了Solidity的安全保障，使用需谨慎
     */
    function inlineAssemblyExample(uint256 a, uint256 b) 
        public 
        pure 
        returns (uint256 sum, uint256 product) 
    {
        assembly {
            // 加法操作
            sum := add(a, b)
            
            // 乘法操作
            product := mul(a, b)
            
            // 条件操作示例
            if gt(a, b) {
                sum := add(sum, 1)
            }
            
            // 循环示例（计算阶乘的一部分）
            let temp := 1
            for { let i := 1 } lt(i, 6) { i := add(i, 1) } {
                temp := mul(temp, i)
            }
            product := add(product, temp)
        }
    }
    // 内联汇编优势：性能优化、底层控制、特殊操作
    // 内联汇编风险：类型安全缺失、编译器优化失效、代码可读性差
    
    /**
     * @dev 函数重载示例 - 相同函数名不同参数
     * Solidity支持函数重载，通过参数类型区分
     * 
     * 重载特性：
     * - 相同函数名，不同参数类型或数量
     * - 编译器根据调用时的参数自动选择
     * - 提高代码可读性和易用性
     * - 避免函数名的重复和复杂化
     */
    
    /**
     * @dev 处理单个数字
     * @param number 要处理的数字
     * @return 数字的平方
     */
    function process(uint256 number) public pure returns (uint256) {
        return number * number;
    }
    
    /**
     * @dev 处理两个数字
     * @param a 第一个数字
     * @param b 第二个数字
     * @return 两数之和
     */
    function process(uint256 a, uint256 b) public pure returns (uint256) {
        return a + b;
    }
    
    /**
     * @dev 处理字符串
     * @param text 要处理的字符串
     * @return 字符串长度
     */
    function process(string memory text) public pure returns (uint256) {
        return bytes(text).length;
    }
    
    /**
     * @dev 处理数组
     * @param inputNumbers 数字数组
     * @return 数组元素之和
     */
    function process(uint256[] memory inputNumbers) public pure returns (uint256) {
        uint256 sum = 0;
        for (uint256 i = 0; i < inputNumbers.length; i++) {
            sum += inputNumbers[i];
        }
        return sum;
    }
    // 函数重载特性：多态性、类型匹配、编译时解析、代码简洁
    
    /**
     * @dev 库函数使用示例 - 安全数学运算
     * 虽然Solidity 0.8+内置溢出检查，但这里演示如何使用库
     * 
     * 库特性：
     * - 代码重用和模块化
     * - 节省部署gas（库只需部署一次）
     * - 类型安全的功能扩展
     * - 无状态，纯逻辑功能
     */
    function safeMathExample(uint256 a, uint256 b) 
        public 
        pure 
        returns (uint256 sum, uint256 diff, uint256 product) 
    {
        // 使用内部安全数学函数
        sum = SafeMath.add(a, b);
        diff = SafeMath.sub(a, b);
        product = SafeMath.mul(a, b);
    }
    
    /**
     * @dev 时间和区块信息示例
     * @return blockNumber 当前区块号
     * @return blockTimestamp 当前区块时间戳
     * @return blockDifficulty 当前区块难度
     * @return blockGasLimit 当前区块gas限制
     * @return txOrigin 交易发起者
     * @return msgSender 消息发送者
     * @return msgValue 消息附带的以太币数量
     * @return gasLeft 剩余gas
     * 
     * 区块链环境变量详解：
     * - block.*：区块相关信息
     * - tx.*：交易相关信息  
     * - msg.*：消息调用相关信息
     * - gasleft()：查询剩余gas
     */
    function blockchainInfoExample() 
        public 
        view 
        returns (
            uint256 blockNumber,
            uint256 blockTimestamp,
            uint256 blockDifficulty,
            uint256 blockGasLimit,
            address txOrigin,
            address msgSender,
            uint256 msgValue,
            uint256 gasLeft
        ) 
    {
        blockNumber = block.number;           // 当前区块号
        blockTimestamp = block.timestamp;     // 当前区块时间戳（Unix时间）
        blockDifficulty = block.prevrandao;   // 当前区块随机数（替代difficulty）
        blockGasLimit = block.gaslimit;       // 当前区块gas限制
        txOrigin = tx.origin;                 // 交易的原始发起者
        msgSender = msg.sender;               // 当前消息的发送者
        msgValue = 0;                         // view函数中msg.value不可访问，设为0
        gasLeft = gasleft();                  // 当前剩余的gas数量
    }
    // 区块链信息用途：时间控制、随机数种子、权限验证、gas优化
    
    /**
     * @dev 哈希函数示例
     * @param data 要哈希的数据
     * @param number 数字
     * @param addr 地址
     * @return keccakHash keccak256哈希值
     * @return sha256Hash sha256哈希值
     * @return ripemd160Hash ripemd160哈希值
     * @return encodedData 编码后的数据
     * 
     * 哈希函数特性：
     * - 单向函数，不可逆
     * - 固定长度输出
     * - 雪崩效应（微小变化导致完全不同的输出）
     * - 抗碰撞性
     */
    function hashFunctionExamples(
        string memory data, 
        uint256 number, 
        address addr
    ) 
        public 
        pure 
        returns (
            bytes32 keccakHash,
            bytes32 sha256Hash,
            bytes20 ripemd160Hash,
            bytes memory encodedData
        ) 
    {
        // ========== 数据编码 ==========
        encodedData = abi.encodePacked(data, number, addr);  // 紧凑编码
        
        // ========== 哈希计算 ==========
        keccakHash = keccak256(encodedData);      // 最常用，gas效率最高
        sha256Hash = sha256(encodedData);         // Bitcoin使用的哈希算法
        ripemd160Hash = ripemd160(encodedData);   // 20字节哈希输出
    }
    // 哈希用途：数据完整性验证、唯一标识生成、Merkle树构建、签名验证
    
    /**
     * @dev 数字签名验证示例
     * @param messageHash 原始消息哈希
     * @param signature 签名数据
     * @param signer 声称的签名者地址
     * @return isValid 签名是否有效
     * 
     * 数字签名特性：
     * - 身份验证：证明消息来自特定地址
     * - 不可否认：签名者无法否认签名
     * - 完整性：消息未被篡改
     * - 椭圆曲线数字签名算法（ECDSA）
     */
    function verifySignature(
        bytes32 messageHash,
        bytes memory signature,
        address signer
    ) public pure returns (bool isValid) {
        // 添加以太坊签名前缀
        bytes32 ethSignedMessageHash = keccak256(
            abi.encodePacked("\x19Ethereum Signed Message:\n32", messageHash)
        );
        
        // 从签名中恢复地址
        address recoveredSigner = recoverSigner(ethSignedMessageHash, signature);
        
        // 验证恢复的地址是否匹配
        isValid = (recoveredSigner == signer);
    }
    
    /**
     * @dev 从签名中恢复签名者地址
     * @param hash 消息哈希
     * @param signature 签名数据
     * @return 签名者地址
     */
    function recoverSigner(bytes32 hash, bytes memory signature) 
        public 
        pure 
        returns (address) 
    {
        require(signature.length == 65, "Invalid signature length");
        
        bytes32 r;
        bytes32 s;
        uint8 v;
        
        // 分离签名组件
        assembly {
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }
        
        // 使用内置的ecrecover函数恢复地址
        return ecrecover(hash, v, r, s);
    }
    // 签名验证用途：身份认证、授权验证、交易确认、多重签名
    
    /**
     * @dev 随机数生成示例（注意：这些方法不适用于真正的随机性需求）
     * @param seed 种子值
     * @return pseudoRandom 伪随机数
     * @return blockBasedRandom 基于区块信息的随机数
     * @return combinedRandom 组合随机数
     * 
     * 重要警告：
     * - 区块链环境是确定性的，真正的随机数很难生成
     * - 矿工可以影响某些区块属性
     * - 对于关键应用，应使用Chainlink VRF等外部随机数服务
     * - 以下示例仅用于教学目的
     */
    function randomNumberExamples(uint256 seed) 
        public 
        view 
        returns (
            uint256 pseudoRandom,
            uint256 blockBasedRandom,
            uint256 combinedRandom
        ) 
    {
        // ========== 简单伪随机数 ==========
        pseudoRandom = uint256(keccak256(abi.encodePacked(seed, msg.sender))) % 100;
        
        // ========== 基于区块信息的随机数 ==========
        blockBasedRandom = uint256(keccak256(abi.encodePacked(
            block.timestamp,
            block.prevrandao,
            block.number
        ))) % 1000;
        
        // ========== 组合多种因素的随机数 ==========
        combinedRandom = uint256(keccak256(abi.encodePacked(
            seed,
            msg.sender,
            block.timestamp,
            block.number,
            block.prevrandao,
            address(this).balance
        ))) % 10000;
    }
    // 随机数安全建议：使用Chainlink VRF、commit-reveal方案、多方随机数协议
    
    /**
     * @dev 合约升级模式示例 - 代理模式基础
     * 注意：这是一个简化的示例，实际的代理模式更加复杂
     * 
     * 升级特性：
     * - 逻辑合约可替换
     * - 存储状态保持不变
     * - 用户交互地址不变
     * - 支持功能迭代和bug修复
     */
    
    address public implementation;  // 实现合约地址
    
    /**
     * @dev 设置新的实现合约（仅限所有者）
     * @param newImplementation 新实现合约地址
     */
    function upgrade(address newImplementation) public onlyOwner {
        require(newImplementation != address(0), "Invalid implementation address");
        require(newImplementation != implementation, "Same implementation");
        
        address oldImplementation = implementation;
        implementation = newImplementation;
        
        emit ImplementationUpgraded(oldImplementation, newImplementation);
    }
    
    // 升级事件
    event ImplementationUpgraded(address indexed oldImplementation, address indexed newImplementation);
    
    /**
     * @dev 委托调用示例
     * @param data 调用数据
     * @return success 调用是否成功
     * @return result 调用结果
     */
    function delegateCallExample(bytes memory data) 
        public 
        returns (bool success, bytes memory result) 
    {
        require(implementation != address(0), "Implementation not set");
        
        // 使用delegatecall调用实现合约
        (success, result) = implementation.delegatecall(data);
        
        if (!success) {
            revert("Delegatecall failed");
        }
    }
    // 委托调用特性：在当前合约上下文中执行目标合约代码、状态变量保留、msg保持不变
    
    /**
     * @dev Gas优化示例函数
     * 展示各种gas优化技巧
     * 
     * 优化技巧：
     * - 使用局部变量缓存状态变量
     * - 优化循环结构
     * - 合理使用memory和storage
     * - 避免不必要的状态变更
     */
    function gasOptimizationExample() public {
        // ========== 状态变量缓存 ==========
        uint256 currentCount = count;  // 缓存状态变量，减少SLOAD操作
        
        // ========== 优化的循环 ==========
        uint256 arrayLength = numbers.length;  // 缓存数组长度
        for (uint256 i = 0; i < arrayLength;) {
            // 处理逻辑
            numbers[i] = numbers[i] * 2;
            
            unchecked {
                ++i;  // 使用unchecked和前置递增节省gas
            }
        }
        
        // ========== 批量状态更新 ==========
        count = currentCount + 1;  // 一次性更新，而不是多次小更新
        
        // ========== 打包结构体优化 ==========
        // 相关的状态变更应该组合进行
        if (currentCount % 10 == 0) {
            isActive = !isActive;
            currentStatus = Status.Active;
        }
    }
    // Gas优化原则：减少存储操作、优化循环、合理使用类型、避免重复计算
}

// ============ 库定义 (Library Definition) ============
// 库是可重用的代码单元，可以被多个合约使用

/**
 * @title SafeMath - 安全数学运算库（示例）
 * @dev 虽然Solidity 0.8+内置溢出检查，但这里演示库的使用方法
 * 
 * 库特性：
 * - 无状态：不包含状态变量
 * - 可重用：可被多个合约使用
 * - Gas效率：库函数通过DELEGATECALL调用
 * - 类型扩展：可以为现有类型添加方法
 */
library SafeMath {
    /**
     * @dev 安全加法
     * @param a 第一个操作数
     * @param b 第二个操作数
     * @return 加法结果
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }
    
    /**
     * @dev 安全减法
     * @param a 被减数
     * @param b 减数
     * @return 减法结果
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        return a - b;
    }
    
    /**
     * @dev 安全乘法
     * @param a 第一个操作数
     * @param b 第二个操作数
     * @return 乘法结果
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }
    
    /**
     * @dev 安全除法
     * @param a 被除数
     * @param b 除数
     * @return 除法结果
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: division by zero");
        return a / b;
    }
}

// ============ 接口定义 (Interface Definition) ============
// 接口定义了合约必须实现的函数签名

/**
 * @title IERC20 - ERC20代币标准接口（简化版）
 * @dev 展示接口的定义和使用方法
 * 
 * 接口特性：
 * - 只包含函数声明，无实现
 * - 定义合约间的交互标准
 * - 支持多态性和抽象
 * - 便于标准化和互操作性
 */
interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// ============ 抽象合约定义 (Abstract Contract Definition) ============
// 抽象合约包含至少一个未实现的函数

/**
 * @title AbstractToken - 抽象代币合约（示例）
 * @dev 展示抽象合约的定义和使用
 * 
 * 抽象合约特性：
 * - 包含未实现的函数
 * - 不能直接部署
 * - 必须被继承并实现所有抽象函数
 * - 可以包含已实现的函数
 */
abstract contract AbstractToken {
    string public name;
    string public symbol;
    
    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
    }
    
    // 抽象函数 - 必须在子合约中实现
    function mint(address to, uint256 amount) public virtual;
    function burn(uint256 amount) public virtual;
    
    // 已实现的函数 - 子合约可以重写
    function getTokenInfo() public view virtual returns (string memory, string memory) {
        return (name, symbol);
    }
}

// ============ 现代 Solidity 特性示例 ============
// 展示 Solidity 0.8+ 的新特性和最佳实践

/**
 * @title ModernSolidityFeatures - 现代Solidity特性演示
 * @dev 展示最新的语言特性和开发实践
 */
contract ModernSolidityFeatures {
    using SafeMath for uint256;  // 库使用声明
    
    // ========== 自定义错误 (Custom Errors) ==========
    // Solidity 0.8.4+ 特性，更节省gas且提供更好的错误信息
    error InsufficientBalance(uint256 available, uint256 required);
    error UnauthorizedAccess(address caller, address required);
    error InvalidParameter(string parameter, uint256 value);
    error TransferFailed(address to, uint256 amount);
    
    // ========== 用户自定义值类型 (User Defined Value Types) ==========
    // Solidity 0.8.8+ 特性，创建强类型包装器
    type Price is uint256;      // 价格类型
    type Quantity is uint256;   // 数量类型
    type UserId is uint256;     // 用户ID类型
    
    // ========== 不可变变量 (Immutable Variables) ==========
    // 部署时设置，之后不可更改，比常量更灵活
    address public immutable deployer;
    uint256 public immutable deploymentTime;
    bytes32 public immutable versionHash;  // 使用bytes32而不是string
    
    // ========== 常量优化 ==========
    uint256 public constant MAX_SUPPLY = 1_000_000 * 10**18;  // 数字分隔符提高可读性
    bytes32 public constant DOMAIN_SEPARATOR = keccak256("EIP712Domain");
    
    // ========== 状态变量 ==========
    mapping(UserId => Price) public userPrices;
    mapping(address => Quantity) public userQuantities;
    
    // ========== 事件定义 ==========
    event PriceUpdated(UserId indexed userId, Price oldPrice, Price newPrice);
    event QuantityChanged(address indexed user, Quantity oldQuantity, Quantity newQuantity);
    
    constructor(string memory _version) {
        deployer = msg.sender;
        deploymentTime = block.timestamp;
        versionHash = keccak256(abi.encodePacked(_version));  // 将版本字符串转换为哈希存储
    }
    
    /**
     * @dev 展示自定义错误的使用
     * @param user 用户地址
     * @param amount 转账金额
     */
    function transferWithCustomErrors(address user, uint256 amount) external {
        uint256 balance = address(this).balance;
        
        // 使用自定义错误，提供详细信息且节省gas
        if (balance < amount) {
            revert InsufficientBalance(balance, amount);
        }
        
        if (msg.sender != deployer) {
            revert UnauthorizedAccess(msg.sender, deployer);
        }
        
        if (user == address(0)) {
            revert InvalidParameter("user", uint256(uint160(user)));
        }
        
        // 执行转账
        (bool success,) = user.call{value: amount}("");
        if (!success) {
            revert TransferFailed(user, amount);
        }
    }
    
    /**
     * @dev 展示用户自定义值类型的使用
     * @param userId 用户ID
     * @param price 价格
     * @param quantity 数量
     */
    function setUserData(UserId userId, Price price, Quantity quantity) external {
        // 类型安全：不能意外混用不同的uint256类型
        userPrices[userId] = price;
        userQuantities[msg.sender] = quantity;
        
        emit PriceUpdated(userId, userPrices[userId], price);
        emit QuantityChanged(msg.sender, userQuantities[msg.sender], quantity);
    }
    
    /**
     * @dev 计算总价值 - 展示类型转换
     * @param userId 用户ID
     * @return totalValue 总价值
     */
    function calculateTotalValue(UserId userId) external view returns (uint256 totalValue) {
        Price price = userPrices[userId];
        Quantity quantity = userQuantities[msg.sender];
        
        // 显式类型转换
        totalValue = Price.unwrap(price) * Quantity.unwrap(quantity);
    }
    
    /**
     * @dev 展示 unchecked 块的使用
     * @param numbers 数字数组
     * @return sum 总和
     * @return average 平均值
     */
    function uncheckedExample(uint256[] calldata numbers) 
        external 
        pure 
        returns (uint256 sum, uint256 average) 
    {
        uint256 length = numbers.length;
        
        // 在确保不会溢出的情况下使用 unchecked 节省gas
        unchecked {
            for (uint256 i = 0; i < length; ++i) {
                sum += numbers[i];
            }
            
            // 除法不会溢出
            average = sum / length;
        }
    }
    
    /**
     * @dev 展示 try-catch 错误处理
     * @param target 目标合约地址
     * @param data 调用数据
     * @return success 是否成功
     * @return returnData 返回数据
     */
    function tryCatchExample(address target, bytes calldata data) 
        external 
        returns (bool success, bytes memory returnData) 
    {
        try this.externalCall(target, data) returns (bytes memory result) {
            // 调用成功
            success = true;
            returnData = result;
        } catch Error(string memory reason) {
            // 捕获 require/revert 产生的错误
            success = false;
            returnData = abi.encodeWithSignature("Error(string)", reason);
        } catch Panic(uint errorCode) {
            // 捕获 assert 失败或其他panic
            success = false;
            returnData = abi.encodeWithSignature("Panic(uint256)", errorCode);
        } catch (bytes memory lowLevelData) {
            // 捕获其他低级错误
            success = false;
            returnData = lowLevelData;
        }
    }
    
    /**
     * @dev 外部调用函数（用于try-catch演示）
     * @param target 目标地址
     * @param data 调用数据
     * @return 调用结果
     */
    function externalCall(address target, bytes calldata data) 
        external 
        returns (bytes memory) 
    {
        (bool success, bytes memory result) = target.call(data);
        require(success, "External call failed");
        return result;
    }
    
    /**
     * @dev 展示字符串字面量和Unicode支持
     * @return info 多语言信息
     */
    function unicodeAndStringLiterals() external pure returns (string memory info) {
        // Unicode字符串字面量
        string memory chinese = unicode"你好，世界！";
        string memory emoji = unicode"🚀🌟💎";
        string memory english = "Hello, World!";
        
        // 十六进制字符串字面量
        string memory hexString = hex"48656c6c6f"; // "Hello"
        
        // 组合字符串
        info = string(abi.encodePacked(
            english, " | ",
            chinese, " | ",
            emoji, " | ",
            hexString
        ));
    }
    
    /**
     * @dev 展示函数选择器和ABI编码
     * @param target 目标地址
     * @param value 数值
     * @param data 数据
     * @return selector 函数选择器
     * @return encodedCall 编码后的调用数据
     */
    function abiEncodingExample(address target, uint256 value, string memory data) 
        external 
        pure 
        returns (bytes4 selector, bytes memory encodedCall) 
    {
        // 获取函数选择器
        selector = this.abiEncodingExample.selector;
        
        // ABI编码
        encodedCall = abi.encodeWithSelector(
            selector,
            target,
            value,
            data
        );
        
        // 其他编码方式示例（返回给调用者）
        bytes memory encodedPacked = abi.encodePacked(target, value, data);
        bytes memory encodedWithSignature = abi.encodeWithSignature(
            "transfer(address,uint256)",
            target,
            value
        );
        
        // 组合所有编码结果返回
        encodedCall = abi.encodePacked(encodedCall, encodedPacked, encodedWithSignature);
    }
    
    /**
     * @dev 展示内存和存储的优化使用
     * @param data 输入数据
     * @return result 处理结果
     */
    function memoryStorageOptimization(uint256[] calldata data) 
        external 
        pure 
        returns (uint256[] memory result) 
    {
        // 使用 calldata 参数（最节省gas）
        uint256 length = data.length;
        
        // 在 memory 中创建结果数组
        result = new uint256[](length);
        
        // 高效的循环处理
        for (uint256 i = 0; i < length;) {
            result[i] = data[i] * 2;
            
            unchecked {
                ++i;
            }
        }
    }
    
    /**
     * @dev 展示位运算优化技巧
     * @param value 输入值
     * @return doubled 乘以2的结果
     * @return halved 除以2的结果
     * @return isEven 是否为偶数
     * @return powersOfTwo 2的幂数组
     */
    function bitwiseOptimizations(uint256 value) 
        external 
        pure 
        returns (
            uint256 doubled,
            uint256 halved,
            bool isEven,
            uint256[] memory powersOfTwo
        ) 
    {
        // 位运算比乘除法更快
        doubled = value << 1;        // 相当于 value * 2
        halved = value >> 1;         // 相当于 value / 2
        isEven = (value & 1) == 0;   // 检查最低位
        
        // 生成2的幂
        powersOfTwo = new uint256[](8);
        for (uint256 i = 0; i < 8;) {
            powersOfTwo[i] = 1 << i;  // 2^i
            
            unchecked {
                ++i;
            }
        }
    }
    
    /**
     * @dev 展示事件的高级用法
     * @param user 用户地址
     * @param amount 金额
     * @param category 类别
     */
    function advancedEventExample(
        address user, 
        uint256 amount, 
        string memory category
    ) external {
        // 匿名事件（节省gas）
        emit AnonymousEvent(user, amount);
        
        // 带有复杂数据的事件
        emit ComplexEvent(
            user,
            amount,
            block.timestamp,
            category,
            msg.sender
        );
        
        // 结构化数据事件
        EventData memory eventData = EventData({
            user: user,
            amount: amount,
            timestamp: block.timestamp,
            category: category
        });
        
        emit StructuredEvent(eventData);
    }
    
    // 事件定义
    event AnonymousEvent(address indexed user, uint256 amount) anonymous;
    event ComplexEvent(
        address indexed user,
        uint256 indexed amount,
        uint256 timestamp,
        string category,
        address sender
    );
    
    struct EventData {
        address user;
        uint256 amount;
        uint256 timestamp;
        string category;
    }
    
    event StructuredEvent(EventData data);
    
    /**
     * @dev 展示接收以太币的现代方法
     */
    receive() external payable {
        // 处理直接的以太币转账
        emit EtherReceived(msg.sender, msg.value, "");
    }
    
    /**
     * @dev 回退函数 - 处理未知函数调用
     */
    fallback() external payable {
        emit EtherReceived(msg.sender, msg.value, "fallback");
    }
    
    event EtherReceived(address indexed sender, uint256 amount, string method);
    
    /**
     * @dev 展示合约的自我检查能力
     * @return contractAddress 合约地址
     * @return contractBalance 合约余额
     * @return contractCodeSize 合约代码大小
     * @return contractCodeHash 合约代码哈希
     * @return deployTime 部署时间
     * @return deployerAddress 部署者地址
     */
    function getContractInfo() external view returns (
        address contractAddress,
        uint256 contractBalance,
        uint256 contractCodeSize,
        bytes32 contractCodeHash,
        uint256 deployTime,
        address deployerAddress
    ) {
        contractAddress = address(this);
        contractBalance = address(this).balance;
        
        // 获取合约代码大小
        assembly {
            contractCodeSize := extcodesize(contractAddress)
            contractCodeHash := extcodehash(contractAddress)
        }
        
        deployTime = deploymentTime;
        deployerAddress = deployer;
    }
    
    /**
     * @dev 辅助函数 - 类型转换工具
     */
    function typeConversions(
        Price price,
        Quantity quantity,
        UserId userId
    ) external pure returns (
        uint256 priceAsUint,
        uint256 quantityAsUint,
        uint256 userIdAsUint
    ) {
        // 自定义类型转换
        priceAsUint = Price.unwrap(price);
        quantityAsUint = Quantity.unwrap(quantity);
        userIdAsUint = UserId.unwrap(userId);
    }
    
    /**
     * @dev 创建自定义类型实例
     */
    function createCustomTypes(
        uint256 priceValue,
        uint256 quantityValue,
        uint256 userIdValue
    ) external pure returns (
        Price price,
        Quantity quantity,
        UserId userId
    ) {
        price = Price.wrap(priceValue);
        quantity = Quantity.wrap(quantityValue);
        userId = UserId.wrap(userIdValue);
    }
}

// ============ 完整的教学总结注释 ============
/*
这个 HelloSolidity 合约是一个全面的 Solidity 语言教学资源，涵盖了：

📚 基础概念：
- 数据类型：uint, int, bool, address, string, bytes
- 状态变量：storage, memory, calldata
- 可见性：public, private, internal, external
- 函数修饰符：view, pure, payable

🔧 数据结构：
- 映射 (mapping)：键值对存储
- 数组 (arrays)：动态和固定长度
- 结构体 (structs)：自定义数据类型
- 枚举 (enums)：有限选项集合

🎛️ 控制流程：
- 条件语句：if-else, 三元运算符
- 循环：for, while, do-while
- 跳转控制：break, continue
- 错误处理：require, assert, revert

⚡ 高级特性：
- 事件 (events)：区块链日志记录
- 修饰符 (modifiers)：函数前置条件
- 继承：合约继承和多态
- 接口：标准化合约交互
- 库：可重用代码模块

🔐 安全实践：
- 访问控制：onlyOwner 等权限管理
- 溢出检查：SafeMath 和内置保护
- 重入攻击防护：检查-效果-交互模式
- 输入验证：require 条件检查

💰 以太币操作：
- payable 函数：接收以太币
- 转账操作：transfer, send, call
- 余额查询：address.balance
- 合约销毁：selfdestruct

🚀 现代特性 (Solidity 0.8+)：
- 自定义错误：节省gas的错误处理
- 用户自定义值类型：强类型安全
- try-catch：外部调用错误处理
- unchecked：优化的算术运算
- Unicode支持：多语言字符串

📊 优化技巧：
- Gas优化：循环优化、存储缓存
- 存储布局：变量打包、槽位优化
- 位运算：高效的数学操作
- 内存管理：memory vs storage

🔗 区块链交互：
- 区块信息：block.timestamp, block.number
- 交易信息：msg.sender, msg.value, tx.origin
- 哈希函数：keccak256, sha256
- 数字签名：ecrecover 验证

这个合约适合：
✅ Solidity 初学者系统学习
✅ 开发者查阅语法参考
✅ 智能合约最佳实践学习
✅ 区块链应用开发入门

每个功能都包含详细注释，解释了：
- 功能用途和特性
- Gas 消耗分析
- 安全考虑
- 实际应用场景
- 最佳实践建议

建议学习路径：
1. 先理解基础数据类型和变量
2. 学习函数定义和修饰符
3. 掌握控制流程和错误处理
4. 深入理解事件和状态管理
5. 学习高级特性和优化技巧
6. 实践安全编程和最佳实践

这个合约将帮助你全面掌握 Solidity 智能合约开发！🎯
*/